<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Gully Inspection System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/togeojson.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background: #f0f0f0;
    }

    #loginScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #loginBox {
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      min-width: 300px;
    }

    #summary { top: 10px; right: 10px; font-size: 0.9em; display: none; }
    .dot { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #000; }
    .popup-form input, .popup-form select, .popup-form textarea { width: 100%; margin-bottom: 6px; }
    .inspection-popup .leaflet-popup-content {
      margin: 5px;
      width: auto !important;
    }
    .popup-form input[type="text"],
    .popup-form input[type="date"],
    .popup-form select,
    .popup-form textarea {
      margin: 5px 0;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .popup-form button {
      background: #f0f0f0;
      border: 1px solid #ccc;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    .popup-form button:hover {
      background: #e0e0e0;
    }
    .popup-form button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .layer-control {
      left: 10px !important;
      right: auto !important;
      top: 10px;
      z-index: 2000 !important;
      background: #fff !important;
      opacity: 1 !important;
      border: 2px solid #888;
      padding: 18px 16px 16px 16px;
      border-radius: 8px;
      min-width: 220px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.25);
    }
    .layer-item {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding: 8px;
      border-radius: 4px;
      background: #f8f8f8;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .layer-item:hover {
      background: #f0f0f0;
    }
    .layer-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    .layer-checkbox {
      width: 18px;
      height: 18px;
      margin: 0;
      cursor: pointer;
    }
    .layer-item label {
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }
    .layer-control select {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .layer-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .layer-content.expanded {
      max-height: 500px;
    }
    .layer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 5px;
      background: #f5f5f5;
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .layer-header:hover {
      background: #e0e0e0;
    }
    .collapse-icon {
      transition: transform 0.3s ease;
    }
    .collapse-icon.expanded {
      transform: rotate(180deg);
    }
    .login-background {
      background: linear-gradient(rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.9)),
                  url('cork_city_hall_night.jpg');
      background-size: cover;
      background-position: center;
    }
    .password-container {
      position: relative;
      display: inline-block;
      width: 100%;
    }
    .password-toggle {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      user-select: none;
    }
    .remember-me {
      margin-top: 10px;
      text-align: left;
    }
    .login-input {
      width: 100%;
      padding: 8px 12px;
      margin: 8px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .login-button {
      background: #2196F3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      font-size: 16px;
      margin-top: 15px;
    }
    .login-button:hover {
      background: #1976D2;
    }
    .ribbon-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 5px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .ribbon-group {
      display: flex;
      gap: 5px;
      padding: 0 10px;
      border-right: 1px solid #ddd;
      flex-shrink: 0;
    }
    .ribbon-group:last-child {
      border-right: none;
    }
    .map-controls {
      position: fixed;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: white;
      padding: 5px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 1000;
    }
    .bottom-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      transition: transform 0.3s ease;
    }
    .bottom-controls.hidden {
      transform: translateY(100%);
    }
    .toggle-controls {
      position: fixed;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 5px 15px;
      border-radius: 8px 8px 0 0;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
      cursor: pointer;
      z-index: 1001;
    }
    .bottom-controls button,
    .bottom-controls select,
    .bottom-controls label.button {
      padding: 8px 15px;
      border-radius: 4px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    .bottom-controls button:hover,
    .bottom-controls select:hover,
    .bottom-controls label.button:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }
    .bottom-controls button:active,
    .bottom-controls select:active,
    .bottom-controls label.button:active {
      background: #e8e8e8;
      transform: translateY(1px);
    }
    .bottom-controls select {
      padding-right: 25px;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 12px;
    }
    .function-tabs {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
    }
    .function-tabs.minimized {
      transform: translateY(calc(100% - 40px));
    }
    .tab-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 15px;
      background: #f0f0f0;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
    }
    .tab-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .tab-content {
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    .tab-group {
      margin-bottom: 15px;
    }
    .tab-group h4 {
      margin: 0 0 10px 0;
      color: #666;
    }
    .function-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }
    .input-group {
      position: relative;
      margin-bottom: 15px;
    }
    .input-group input {
      width: 100%;
    }
    .input-group datalist {
      position: absolute;
      max-height: 200px;
      overflow-y: auto;
      width: 100%;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 1000;
    }
    .bottom-toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 1001;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      padding: 0;
    }
    .bottom-toolbar.minimized {
      transform: translateY(calc(100% - 40px));
    }
    .toolbar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 15px;
      background: #f0f0f0;
      cursor: pointer;
    }
    .toolbar-header h3 {
      margin: 0;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      padding: 4px 12px;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .user-role {
      font-weight: bold;
      color: #2196F3;
    }
    .toolbar-content {
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-evenly;
      gap: 10px;
      padding: 10px 0 10px 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      background: none;
    }
    .button-group {
      display: flex;
      flex-direction: row;
      gap: 8px;
      padding: 0;
      border: none;
      align-items: center;
      margin: 0;
    }
    .button-group.admin-only {
      margin-right: 0;
    }
    .toolbar-button {
      padding: 8px 15px;
      border-radius: 4px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s ease;
    }
    .toolbar-button:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }
    .toolbar-button:active {
      background: #e8e8e8;
      transform: translateY(1px);
    }
    .summary-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
        z-index: 2000;
        max-width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        border: 1px solid #e0e0e0;
    }

    .summary-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid #f0f0f0;
    }

    .summary-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 16px;
        margin-top: 10px;
    }

    .status-item {
        min-height: 160px;
    }

    .status-card {
        background: white;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        transition: all 0.3s ease;
        height: 100%;
        position: relative;
        overflow: hidden;
    }

    .status-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        border-color: #007bff;
    }

    .status-card .card-body {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .status-count {
        font-size: 1.5rem;
        font-weight: bold;
        margin: 8px 0;
    }

    .status-description {
        font-size: 0.85rem;
        line-height: 1.4;
        flex-grow: 1;
    }

    .status-icon {
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }



    .status-description {
        font-size: 0.9em;
        color: #666;
    }

    .loading-spinner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 2000;
        text-align: center;
    }

    .spinner {
        width: 40px;
        height: 40px;
        margin: 10px auto;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    #add-tooltip {
        display: none;
        position: fixed;
        background: white;
        padding: 5px 10px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        pointer-events: none;
        font-size: 12px;
    }
    .layer-button {
      position: relative;
      padding-left: 30px !important;
    }

    .layer-button.active {
      background-color: #e3f2fd !important;
      border-color: #2196F3 !important;
    }

    .layer-button:hover {
      background-color: #f0f0f0;
    }
  </style>
  <style>
    .inspection-popup .leaflet-popup-content {
      padding: 18px 14px 10px 14px !important;
      border-radius: 12px !important;
      box-shadow: 0 4px 16px rgba(0,0,0,0.18) !important;
      font-size: 15px !important;
      background: #fff !important;
      min-width: 260px;
      max-width: 340px;
    }
    .inspection-popup h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.2em;
      font-weight: bold;
    }
    .inspection-popup .popup-form > div {
      margin-bottom: 8px;
    }
    .inspection-popup input[type="text"],
    .inspection-popup input[type="date"],
    .inspection-popup select {
      padding: 5px 8px;
      border-radius: 5px;
      border: 1px solid #bbb;
      font-size: 1em;
      margin-top: 2px;
    }
    .inspection-popup button {
      border-radius: 5px;
      border: 1px solid #bbb;
      background: #f8f8f8;
      padding: 5px 12px;
      font-size: 1em;
      margin-right: 6px;
      margin-top: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .inspection-popup button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .inspection-popup button:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .inspection-popup label {
      margin-bottom: 0;
      font-size: 1em;
    }
    .inspection-popup img {
      border-radius: 6px;
      margin-top: 4px;
      border: 1px solid #eee;
    }
  </style>
  <style>
/* Add responsive and modal styles for custom elements */
@media (max-width: 900px) {
  .bottom-toolbar, .toolbar-content, .toolbar-header {
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 0 !important;
  }
  .button-group {
    flex-direction: column !important;
    gap: 4px !important;
  }
  .toolbar-button, .login-button {
    width: 100% !important;
    font-size: 16px !important;
  }
  .summary-popup, .user-management-modal {
    max-width: 98vw !important;
    max-height: 90vh !important;
    padding: 10px !important;
  }
}
@media (max-width: 600px) {
  #loginBox {
    min-width: unset !important;
    width: 95vw !important;
    padding: 10px !important;
  }
  .summary-popup, .user-management-modal {
    left: 50% !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    width: 98vw !important;
    max-width: 98vw !important;
    padding: 5px !important;
  }
  .toolbar-header h3, .toolbar-header span {
    font-size: 14px !important;
  }
}
.modal-backdrop-custom {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.35);
  z-index: 1999;
  display: flex;
  align-items: center;
  justify-content: center;
}
  </style>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    .toolbar-button, .btn {
      color: #111 !important;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    .btn .bi, .toolbar-button .bi {
      margin-right: 4px;
    }
    .toolbar-content {
      display: flex !important;
      flex-wrap: nowrap !important;
      justify-content: space-between !important;
      gap: 8px !important;
      width: 100%;
      overflow-x: auto;
    }
    .button-group {
      display: flex !important;
      flex-wrap: nowrap !important;
      gap: 8px !important;
      width: 100%;
    }
    @media (max-width: 900px) {
      .toolbar-content, .button-group {
        flex-wrap: wrap !important;
        justify-content: flex-start !important;
        gap: 4px !important;
      }
    }
  </style>
  <style>
    /* Responsive improvements for summary popup on desktop/laptop */
    @media (min-width: 900px) {
      .summary-popup {
        max-width: 900px !important;
      }
      .summary-content {
        display: flex !important;
        flex-wrap: wrap;
        justify-content: center;
        gap: 24px;
      }
      .status-card {
        min-width: 220px;
        max-width: 260px;
        flex: 1 1 220px;
      }
    }
  </style>
  <style>
/* Add new styles for a modern Bootstrap card popup */
.layer-control-card {
  position: absolute;
  left: 24px;
  top: 24px;
  z-index: 3000;
  min-width: 320px;
  max-width: 380px;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1);
  border: 1px solid #e0e0e0;
  background: white;
  padding: 0;
  margin: 0;
  font-family: 'Segoe UI', Arial, sans-serif;
  transition: all 0.3s ease;
  overflow: hidden;
}

.layer-control-card:hover {
  box-shadow: 0 12px 40px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.15);
}

.layer-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 16px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.layer-header-content {
  display: flex;
  align-items: center;
  flex: 1;
}

.drag-handle {
  color: rgba(255,255,255,0.8);
  font-size: 1.2rem;
  cursor: move;
  user-select: none;
  margin-right: 12px;
  transition: color 0.2s ease;
}

.drag-handle:hover {
  color: white;
}

.layer-title {
  display: flex;
  align-items: center;
  font-size: 1.1rem;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.layer-close-btn {
  background: none;
  border: none;
  color: rgba(255,255,255,0.8);
  font-size: 1.1rem;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.layer-close-btn:hover {
  color: white;
  background: rgba(255,255,255,0.1);
}

.layer-content {
  padding: 20px;
}

.layer-description {
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #f0f0f0;
}

.layer-list {
  display: flex !important;
  flex-direction: column;
  gap: 8px;
  min-height: 200px;
  border: 1px solid #e0e0e0;
  background: #f8f9fa;
  padding: 8px;
  border-radius: 6px;
}

.layer-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid transparent;
}

.layer-item:hover {
  background: #f8f9fa;
  border-color: #e9ecef;
  transform: translateX(2px);
}

.layer-checkbox {
  margin-right: 12px;
}

.layer-checkbox .form-check-input {
  width: 18px;
  height: 18px;
  border: 2px solid #dee2e6;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.layer-checkbox .form-check-input:checked {
  background-color: #667eea;
  border-color: #667eea;
}

.layer-icon-container {
  margin-right: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.layer-icon {
  width: 24px;
  height: 24px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.gully-icon {
  background: #2196F3;
  border: 2px solid #1976D2;
}

.playground-icon {
  background: #4CAF50;
  border: 2px solid #388E3C;
}

.walkway-icon {
  background: #F44336;
  border: 2px solid #D32F2F;
}

.signage-icon {
  background: #FF9800;
  border: 2px solid #F57C00;
}

.lining-icon {
  background: #9C27B0;
  border: 2px solid #7B1FA2;
}

.layer-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.layer-name {
  font-weight: 600;
  color: #2c3e50;
  font-size: 0.95rem;
  margin-bottom: 2px;
}

.layer-description {
  font-size: 0.8rem;
  color: #6c757d;
  line-height: 1.3;
}

/* Responsive Design */
@media (max-width: 768px) {
  .layer-control-card {
    min-width: 90vw !important;
    max-width: 95vw !important;
    left: 2.5vw !important;
    top: 2.5vw !important;
  }
  
  .layer-header {
    padding: 20px !important;
  }
  
  .layer-content {
    padding: 24px !important;
  }
  
  .layer-item {
    padding: 16px 20px !important;
  }
  
  .layer-icon {
    width: 28px !important;
    height: 28px !important;
  }
  
  .layer-name {
    font-size: 1rem !important;
  }
  
  .layer-description {
    font-size: 0.85rem !important;
  }
}
  </style>
  <style>
    /* ... existing styles ... */
    @media (max-width: 900px) {
      .layer-control-card {
        min-width: 90vw !important;
        max-width: 98vw !important;
        left: 2vw !important;
        top: 2vw !important;
        font-size: 1.12em !important;
        padding: 0 !important;
      }
      .layer-control-card .card-header {
        font-size: 1.25em !important;
        padding: 1.1em 1.2em 1em 1.2em !important;
      }
      .layer-control-card .list-group-item {
        font-size: 1.13em !important;
        padding: 1.1em 1.2em !important;
        gap: 1.2em !important;
      }
      .layer-control-card .form-check-input {
        width: 1.7em !important;
        height: 1.7em !important;
      }
      .layer-control-card .layer-icon {
        width: 32px !important;
        height: 32px !important;
        font-size: 1.5em !important;
      }
    }
  </style>
  <style>
    /* ... existing styles ... */
    @media (max-width: 900px) {
      #loginBox, .card.shadow-lg.p-0 {
        min-width: unset !important;
        width: 98vw !important;
        max-width: 98vw !important;
        padding: 10px !important;
        border-radius: 14px !important;
      }
      #loginScreen .container {
        min-height: 100vh !important;
        padding: 0 !important;
      }
      #loginScreen .d-flex.flex-row {
        flex-direction: column !important;
        align-items: stretch !important;
      }
      #loginScreen .d-flex.flex-column.align-items-center.justify-content-center.gap-3.p-4 {
        display: none !important;
      }
      #loginScreen .d-flex.align-items-center.justify-content-between.px-4.py-3 {
        flex-direction: column !important;
        gap: 0.5em !important;
        padding: 0.7em 0.5em !important;
        text-align: center !important;
      }
      #loginScreen img[alt="Cork City Council Logo"] {
        height: 38px !important;
        max-width: 90vw !important;
      }
      #loginScreen span[style*="font-size:1.5rem"] {
        font-size: 1.1rem !important;
      }
      #loginScreen span[style*="font-size:1.35rem"] {
        font-size: 1.05rem !important;
      }
      #loginScreen .flex-grow-1.p-4 {
        padding: 1em 0.5em !important;
        min-width: unset !important;
      }
      #loginForm .form-control, #loginForm .form-control-lg {
        font-size: 1.08em !important;
        padding: 0.7em 1em !important;
      }
      #loginForm .btn, #loginForm .btn-lg {
        font-size: 1.08em !important;
        padding: 0.7em 1em !important;
      }
      #loginForm label.form-label {
        font-size: 1.05em !important;
      }
      #forgotPasswordLink {
        font-size: 0.98em !important;
      }
    }
    @media (max-width: 600px) {
      #loginBox, .card.shadow-lg.p-0 {
        min-width: unset !important;
        width: 99vw !important;
        max-width: 99vw !important;
        padding: 4px !important;
        border-radius: 10px !important;
      }
      #loginScreen .d-flex.align-items-center.justify-content-between.px-4.py-3 {
        flex-direction: column !important;
        gap: 0.3em !important;
        padding: 0.5em 0.2em !important;
      }
      #loginScreen img[alt="Cork City Council Logo"] {
        height: 28px !important;
        max-width: 90vw !important;
      }
      #loginScreen span[style*="font-size:1.5rem"] {
        font-size: 0.98rem !important;
      }
      #loginScreen span[style*="font-size:1.35rem"] {
        font-size: 0.92rem !important;
      }
      #loginScreen .flex-grow-1.p-4 {
        padding: 0.7em 0.2em !important;
      }
      #loginForm .form-control, #loginForm .form-control-lg {
        font-size: 1em !important;
        padding: 0.6em 0.7em !important;
      }
      #loginForm .btn, #loginForm .btn-lg {
        font-size: 1em !important;
        padding: 0.6em 0.7em !important;
      }
      #loginForm label.form-label {
        font-size: 0.98em !important;
      }
      #forgotPasswordLink {
        font-size: 0.92em !important;
      }
    }
  </style>
  <style>
    #loginScreen.login-background {
      background: url('cork_city_hall_night.jpg') !important;
      background-size: cover !important;
      background-position: center !important;
      min-height: 100vh !important;
    }
    /* Hide Show Layers button when login screen is visible */
    #loginScreen.login-background ~ .toggle-layers {
      display: none !important;
    }
  </style>
</head>
<body>
<div id="map" style="width:100vw; height:100vh; min-height:400px;"></div>

<!-- LOGIN PAGE HEADER -->
<div id="loginScreen" class="login-background" style="min-height:100vh;">
  <div class="container d-flex align-items-center justify-content-center" style="min-height:100vh;">
    <div class="card shadow-lg p-0" style="max-width:700px;width:100%;border-radius:18px;overflow:hidden;">
      <!-- Header Bar -->
      <div class="d-flex align-items-center justify-content-between px-4 py-3" style="background:#fff;border-bottom:1px solid #eee;">
        <div class="d-flex align-items-center gap-3">
          <img src="cork-city-council-logo.jpg" alt="Cork City Council Logo" style="height:48px;width:auto;">
          <span style="font-size:1.5rem;font-weight:700;letter-spacing:1px;">CORK CITY COUNCIL</span>
        </div>
        <span style="font-size:1.35rem;font-weight:600;">Asset Management System (Roads)</span>
      </div>
      <div class="d-flex flex-row">
        <!-- Main Login Form -->
        <div class="flex-grow-1 p-4" style="min-width:320px;">
          <h2 class="mb-2" style="font-weight:700;">Asset Management System (Roads)</h2>
          <div class="mb-3" style="font-size:1.1rem;color:#444;">Please sign in to continue.</div>
          <form id="loginForm" autocomplete="on" onsubmit="event.preventDefault(); login();">
            <div class="mb-3">
              <label for="email" class="form-label" style="font-weight:500;">Username</label>
              <input type="email" id="email" placeholder="Username" class="form-control form-control-lg" autocomplete="username" style="font-size:1.1rem;">
            </div>
            <div class="mb-3 position-relative" style="width:100%;">
              <label for="password" class="form-label" style="font-weight:500;">Password</label>
              <input type="password" id="password" placeholder="Password" class="form-control form-control-lg" autocomplete="current-password" style="font-size:1.1rem; padding-right: 2.5rem;">
              <span class="password-toggle" onclick="togglePassword()" title="Show or hide password" style="position:absolute;right:18px;top:50%;transform:translateY(-50%);cursor:pointer;font-size:1.3rem;color:#888;z-index:2;display:flex;align-items:center;height:2.5rem;width:2.5rem;justify-content:center;">
                <i id="passwordToggleIcon" class="bi bi-eye" style="margin-top:35px;"></i>
              </span>
            </div>
            <button type="button" class="btn btn-primary btn-lg w-100 mb-2" onclick="login()" style="font-weight:600;font-size:1.15rem;">Sign In</button>
            <button type="button" class="btn btn-outline-primary w-100 mt-2" onclick="showRegisterModal()">Register</button>
            <div class="text-start mt-2">
              <a href="#" id="forgotPasswordLink" style="color:#1976D2;text-decoration:underline;cursor:pointer;font-size:1rem;">Forgot password?</a>
            </div>
            <p id="loginError" style="color:red;margin-top:10px;"></p>
          </form>
        </div>
        <!-- Sidebar Icons -->
        <div class="d-flex flex-column align-items-center justify-content-center gap-3 p-4" style="background:#f8f9fa;min-width:90px;">
          <div style="background:#1976d2;border-radius:12px;width:56px;height:56px;display:flex;align-items:center;justify-content:center;">
            <i class="bi bi-map" style="font-size:2rem;color:#fff;"></i>
          </div>
          <div style="background:#388e3c;border-radius:12px;width:56px;height:56px;display:flex;align-items:center;justify-content:center;">
            <i class="bi bi-wrench" style="font-size:2rem;color:#fff;"></i>
          </div>
          <div style="background:#fbc02d;border-radius:12px;width:56px;height:56px;display:flex;align-items:center;justify-content:center;">
            <i class="bi bi-archive" style="font-size:2rem;color:#fff;"></i>
          </div>
          <div style="background:#6c4eb6;border-radius:12px;width:56px;height:56px;display:flex;align-items:center;justify-content:center;">
            <i class="bi bi-bar-chart" style="font-size:2rem;color:#fff;"></i>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- END LOGIN PAGE HEADER -->

<div class="toggle-layers" onclick="toggleLayerControl()">🗺️ Show Layers</div>

<div class="bottom-toolbar bg-light border-top" id="functionToolbar">
  <div class="toolbar-header d-flex align-items-center justify-content-between p-2" onclick="toggleToolbar()">
    <h3 class="m-0 d-flex align-items-center gap-2">
      <span>Gully Inspection System</span>
      <span class="user-info ms-2">
        <span id="userInitials" style="font-weight:bold; color:#0056b3;"></span>
        <span id="userName"></span>
      </span>
    </h3>
    <span id="toolbarToggleIcon">▼</span>
  </div>
  <div class="toolbar-content d-flex flex-nowrap gap-2 p-2 w-100">
    <div class="button-group admin-only d-flex flex-nowrap gap-2 w-100">
      <button class="btn btn-secondary toolbar-button d-inline-flex align-items-center" onclick="showUserManagement()" title="Manage users"><i class="bi bi-person"></i> <span>Users</span></button>
      <button class="btn btn-secondary toolbar-button d-inline-flex align-items-center" onclick="logout()" title="Log out of your account"><i class="bi bi-box-arrow-right"></i> <span>Logout</span></button>
      <button class="btn btn-warning toolbar-button d-inline-flex align-items-center" onclick="enableEditMode()" title="Enable edit mode"><i class="bi bi-pencil"></i> <span>Edit</span></button>
      <button class="btn btn-danger toolbar-button d-inline-flex align-items-center" onclick="enableDeleteMode()" title="Enable delete mode"><i class="bi bi-trash"></i> <span>Delete</span></button>
      <button class="btn btn-success toolbar-button d-inline-flex align-items-center" onclick="enableAddMode()" title="Add a new item"><i class="bi bi-plus"></i> <span>Add New</span></button>
    </div>
    <div class="button-group d-flex flex-nowrap gap-2 w-100">
      <button class="btn btn-outline-secondary toolbar-button d-inline-flex align-items-center" onclick="printMap()" title="Print the current map view"><i class="bi bi-printer"></i> <span>Print</span></button>
      <button class="btn btn-outline-secondary toolbar-button d-inline-flex align-items-center" onclick="resetMap()" title="Reset the map to its default state"><i class="bi bi-arrow-repeat"></i> <span>Reset</span></button>
      <button class="btn btn-outline-info toolbar-button d-inline-flex align-items-center" onclick="showSummaryPopup()" title="Show summary statistics"><i class="bi bi-bar-chart"></i> <span>Summary</span></button>
      <button class="btn btn-outline-secondary toolbar-button d-inline-flex align-items-center" onclick="showLayerControl()" title="Show or hide map layers"><i class="bi bi-layers"></i> <span>Layers</span></button>
      <button class="btn btn-outline-info toolbar-button d-inline-flex align-items-center" onclick="showSearchPopup()" title="Search for gullies, parks, or assets"><i class="bi bi-search"></i> <span>Search</span></button>
      <label for="importFile" class="btn btn-outline-primary toolbar-button d-inline-flex align-items-center" title="Import data from a file"><i class="bi bi-upload"></i> <span>Import</span></label>
      <input type="file" id="importFile" onchange="handleImportFile(event)" style="display: none;">
      <button class="btn btn-outline-success toolbar-button d-inline-flex align-items-center" onclick="exportData()" title="Export data as CSV file"><i class="bi bi-download"></i> <span>Export CSV</span></button>
      <button class="btn btn-outline-warning toolbar-button d-inline-flex align-items-center" onclick="saveGullyData()" title="Backup all gully data"><i class="bi bi-save"></i> <span>Backup</span></button>
      <button class="btn btn-outline-primary toolbar-button d-inline-flex align-items-center" onclick="loadFromBackup()" title="Load data from a backup file"><i class="bi bi-folder"></i> <i class="bi bi-arrow-up"></i> <span>Load Backup</span></button>
      <button class="btn btn-outline-secondary toolbar-button d-inline-flex align-items-center" id="toggleMapLayerBtn" onclick="toggleMapLayer()" title="Switch between Map and Satellite"><i class="bi bi-globe"></i> Satellite</button>
    </div>
  </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBsteq-tHQdiDcRk5UBg52AwAxpVcq67cw",
  authDomain: "gullytest3.firebaseapp.com",
  databaseURL: "https://gullytest3-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "gullytest3",
  storageBucket: "gullytest3.appspot.com",
  messagingSenderId: "876083677912",
  appId: "1:876083677912:web:065de0c7cca446b78f65ad"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
const storage = firebase.storage();

// User management configuration
const USER_CONFIG = {
  // defaultPassword: 'DefaultPass123!', // Removed for security
  users: [
    {
      email: 'shane_dorgan@corkcity.ie',
      role: 'admin',
      name: 'Shane Dorgan',
      initials: 'SD',
      isAdmin: true,
      adminPrivileges: {
        canDelete: true,
        canEdit: true,
        canImport: true,
        canExport: true,
        canReset: true,
        canManageUsers: true
      }
    },
    {
      email: 'aman_kushwaha@corkcity.ie',
      role: 'admin',
      name: 'Aman Kushwaha',
      initials: 'AK',
      isAdmin: true,
      adminPrivileges: {
        canDelete: true,
        canEdit: true,
        canImport: true,
        canExport: true,
        canReset: true,
        canManageUsers: true
      },
      tempPassword: 'TempAman2024!'
    },
    {
      email: 'richard_daly@corkcity.ie',
      role: 'admin',
      name: 'Richard Daly',
      initials: 'RD',
      isAdmin: true,
      adminPrivileges: {
        canDelete: true,
        canEdit: true,
        canImport: true,
        canExport: true,
        canReset: true,
        canManageUsers: true
      }
    },
    {
      email: 'ronan_oconnor@corkcity.ie',
      role: 'operator',
      name: "Ronan O'Connor",
      initials: 'RO',
      isAdmin: false
    },
    // Added John O'Callaghan
    {
      email: 'john_ocallaghan@corkcity.ie',
      role: 'operator',
      name: "John O'Callaghan",
      initials: 'JO',
      isAdmin: false
    },
    // Added Viewer
    {
      email: 'viewer@corkcity.ie',
      role: 'viewer',
      name: 'Viewer',
      initials: 'VW',
      isAdmin: false
    },
    // Added Eoin Doyle
    {
      email: 'eoin_doyle@corkcity.ie',
      role: 'operator',
      name: 'Eoin Doyle',
      initials: 'ED',
      isAdmin: false
    },
    // Added Dan Corcoran
    {
      email: 'dan_corcoran@corkcity.ie',
      role: 'operator',
      name: 'Dan Corcoran',
      initials: 'DC',
      isAdmin: false
    },
    // Added Flor Crowley
    {
      email: 'flor_crowley@corkcity.ie',
      role: 'operator',
      name: 'Flor Crowley',
      initials: 'FC',
      isAdmin: false
    },
    // Added Martin McCormick
    {
      email: 'martin_mccormick@corkcity.ie',
      role: 'operator',
      name: 'Martin McCormick',
      initials: 'MM',
      isAdmin: false
    }
  ]
};

// Function to validate and normalize email variations
function validateAndNormalizeEmail(email) {
  if (!email) return { isValid: false, normalizedEmail: '', message: 'Email is required' };
  
  email = email.toLowerCase().trim();
  
  // Admin email variations
  const adminVariations = [
    'shane_dorgan@corkcity.ie',
    'shane.dorgan@corkcity.ie',
    'shanedorgan@corkcity.ie',
    'aman_kushwaha@corkcity.ie',
    'aman.kushwaha@corkcity.ie',
    'nan_kushwaha@corkcity.ie',
    'nan.kushwaha@corkcity.ie',
    'aman_kushawaha@corkcity.ie',
    'aman.kushawaha@corkcity.ie',
    'amankushwaha@corkcity.ie',
    'nankushwaha@corkcity.ie',
    'richard_daly@corkcity.ie',
    'richard.daly@corkcity.ie',
    'richarddaly@corkcity.ie'
  ];
  
  // Operator email variations
  const operatorVariations = [
    'ronan_oconnor@corkcity.ie',
    'ronan.oconnor@corkcity.ie',
    'ronan_o_connor@corkcity.ie',
    'ronan.o.connor@corkcity.ie',
    'ronanoconnor@corkcity.ie',
    // Add John O'Callaghan variations
    'john_ocallaghan@corkcity.ie',
    'john.ocallaghan@corkcity.ie',
    'john_o_callaghan@corkcity.ie',
    'john.o.callaghan@corkcity.ie',
    'johnocallaghan@corkcity.ie'
  ];
  
  // Viewer email variations
  const viewerVariations = [
    'viewer@corkcity.ie'
  ];
  
  // Check admin variations
  if (adminVariations.some(variant => 
    email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
    // Determine which admin user
    let adminUser = USER_CONFIG.users[0];
    if (['aman_kushwaha@corkcity.ie','aman.kushwaha@corkcity.ie','nan_kushwaha@corkcity.ie','nan.kushwaha@corkcity.ie','aman_kushawaha@corkcity.ie','aman.kushawaha@corkcity.ie','amankushwaha@corkcity.ie','nankushwaha@corkcity.ie'].some(variant => email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
      adminUser = USER_CONFIG.users[1];
    } else if (['richard_daly@corkcity.ie','richard.daly@corkcity.ie','richarddaly@corkcity.ie'].some(variant => email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
      adminUser = USER_CONFIG.users[2];
    }
    return {
      isValid: true,
      normalizedEmail: adminUser.email,
      isAdmin: true,
      userData: adminUser,
      message: 'Admin email validated'
    };
  }
  
  // Check operator variations
  if (operatorVariations.some(variant => 
    email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
    // Determine which operator user
    let operatorUser = USER_CONFIG.users.find(u =>
      u.email.replace(/[._]/g, '').toLowerCase() === email.replace(/[._]/g, '').toLowerCase()
    );
    if (!operatorUser) operatorUser = USER_CONFIG.users.find(u => u.role === 'operator');
    return {
      isValid: true,
      normalizedEmail: operatorUser.email,
      isAdmin: false,
      userData: operatorUser,
      message: 'Operator email validated'
    };
  }
  
  // Check viewer variations
  if (viewerVariations.some(variant => 
    email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
    const viewerUser = USER_CONFIG.users.find(u => u.role === 'viewer');
    return {
      isValid: true,
      normalizedEmail: viewerUser.email,
      isAdmin: false,
      userData: viewerUser,
      message: 'Viewer email validated'
    };
  }
  
  return {
    isValid: false,
    normalizedEmail: '',
    message: 'Invalid email. Must be an authorized @corkcity.ie address'
  };
}

// Function to handle URL parameters - only pre-fill email, no auto-login
function handleAutoLogin() {
  const urlParams = new URLSearchParams(window.location.search);
  const email = urlParams.get('email');
  const autoLogin = urlParams.get('autologin');
  
  // Only pre-fill email if provided, regardless of autologin parameter
  if (email) {
    const validation = validateAndNormalizeEmail(email);
    if (validation.isValid) {
      document.getElementById('email').value = validation.normalizedEmail;
      // Clear any existing error messages
      document.getElementById('loginError').textContent = '';
    } else {
      document.getElementById('loginError').textContent = `❌ ${validation.message}`;
    }
  }
  
  // Always ensure login screen is visible when URL parameters are present
  // This prevents automatic login from remembered sessions
  if (email || autoLogin) {
    // Force logout if user is already logged in
    if (auth.currentUser) {
      console.log('handleAutoLogin: Forcing logout due to URL parameters');
      auth.signOut();
    }
    
    // Clear any existing authentication state from localStorage
    localStorage.removeItem('rememberedEmail');
    sessionStorage.clear();
    
    // Ensure login screen is visible
    const loginScreen = document.getElementById('loginScreen');
    const map = document.getElementById('map');
    const functionToolbar = document.getElementById('functionToolbar');
    const summary = document.getElementById('summary');
    
    if (loginScreen) loginScreen.style.display = 'flex';
    if (map) map.style.display = 'none';
    if (functionToolbar) functionToolbar.style.display = 'none';
    if (summary) summary.style.display = 'none';
    
    // Clear URL parameters to prevent future auto-login attempts
    window.history.replaceState({}, document.title, window.location.pathname);
    
    console.log('handleAutoLogin: Login screen forced visible due to URL parameters');
  }
}

// Function to ensure all users exist
async function ensureAllUsers() {
  console.log('Ensuring all users exist...');
  for (const user of USER_CONFIG.users) {
    try {
      // Check if user exists
      const methods = await auth.fetchSignInMethodsForEmail(user.email);
      if (methods.length === 0) {
        console.log(`Creating new user: ${user.email}`);
        // Create new user with a random temporary password
        const tempPassword = Math.random().toString(36) + 'Aa!';
        const userCredential = await auth.createUserWithEmailAndPassword(
          user.email,
          tempPassword
        );
        // Send password reset email immediately
        await auth.sendPasswordResetEmail(user.email);
        // Set up user data
        await db.ref(`users/${userCredential.user.uid}`).set({
          ...user,
          created: firebase.database.ServerValue.TIMESTAMP,
          lastUpdated: firebase.database.ServerValue.TIMESTAMP
        });
        console.log(`Successfully created user: ${user.email}`);
      } else {
        console.log(`User already exists: ${user.email}`);
        // Don't try to update existing users - this requires authentication
        // Users should be updated through the Firebase Console or admin panel
      }
    } catch (error) {
      if (error.code === 'auth/email-already-in-use') {
        console.log(`User ${user.email} already exists (auth error)`);
      } else {
        console.error(`Error setting up user ${user.email}:`, error);
      }
    }
  }
  console.log('User setup complete');
}

// Update login function with better error handling
function login(isAutoLogin = false) {
  console.log('login: Starting login process...', new Date().toISOString());
  console.log('login: isAutoLogin =', isAutoLogin);
  
  try {
    // Check if required elements exist
    const emailElement = document.getElementById("email");
    const passwordElement = document.getElementById("password");
    const errorElement = document.getElementById("loginError");
    
    if (!emailElement || !passwordElement || !errorElement) {
      console.error('login: Required DOM elements not found');
      alert('Login form elements not found. Please refresh the page.');
      return;
    }
    
    const email = emailElement.value;
    const password = passwordElement.value;
    
    console.log('login: Email and password retrieved');
    
    if (!email || !password) {
      document.getElementById("loginError").textContent = "❌ Please enter both email and password";
      const loginScreen = document.getElementById("loginScreen");
      if (loginScreen) loginScreen.style.opacity = "1";
      return;
    }

    const validation = validateAndNormalizeEmail(email);
    if (!validation.isValid) {
      document.getElementById("loginError").textContent = `❌ ${validation.message}`;
      const loginScreen = document.getElementById("loginScreen");
      if (loginScreen) loginScreen.style.opacity = "1";
      return;
    }

    console.log('login: Email validation passed, attempting Firebase sign in...');
    
    document.getElementById("loginError").textContent = "Logging in...";
    const loginScreen = document.getElementById("loginScreen");
    if (loginScreen) loginScreen.style.opacity = "0.5";

    // Check if Firebase auth is available
    if (!auth || typeof auth.signInWithEmailAndPassword !== 'function') {
      console.error('login: Firebase auth not available');
      console.error('login: auth object:', auth);
      console.error('login: typeof auth.signInWithEmailAndPassword:', typeof auth.signInWithEmailAndPassword);
      document.getElementById("loginError").textContent = "❌ Authentication service not available. Please refresh the page.";
      if (loginScreen) loginScreen.style.opacity = "1";
      return;
    }
    
    console.log('login: Firebase auth is available, proceeding with sign in...');

    auth.signInWithEmailAndPassword(validation.normalizedEmail, password)
    .then(async userCredential => {
      console.log('login: Firebase sign in successful, getting user data...');
      
      try {
        const userRef = db.ref(`users/${userCredential.user.uid}`);
        let snapshot = await userRef.once('value');
        
        if (!snapshot.exists()) {
          console.log('login: No user data found, checking USER_CONFIG...');
          // Try to find user config for this email
          const userConfig = USER_CONFIG.users.find(u => u.email.toLowerCase() === validation.normalizedEmail.toLowerCase());
          if (userConfig) {
            console.log('login: User config found, creating user data...');
            // Create user data in DB
            await userRef.set({
              ...userConfig,
              created: firebase.database.ServerValue.TIMESTAMP,
              lastUpdated: firebase.database.ServerValue.TIMESTAMP
            });
            // Re-fetch snapshot
            snapshot = await userRef.once('value');
          } else {
            throw new Error('No user data found and no config for this user');
          }
        }
        
        if (!snapshot.exists()) {
          throw new Error('No user data found');
        }
        
        const userData = snapshot.val();
        console.log('login: User data retrieved:', userData);
        
        if (userData.approved === false) {
          throw new Error('Your account is pending admin approval. Please contact an administrator.');
        }
        
        window.currentUserData = userData;
        currentRole = userData.role;
        
        console.log('login: Calling handleLoginSuccess...');
        // Use handleLoginSuccess instead of duplicating UI logic
        handleLoginSuccess(userData);
        
        // Clear URL parameters after auto-login
        if (isAutoLogin) {
          window.history.replaceState({}, document.title, window.location.pathname);
        }
      } catch (error) {
        console.error('login: Error in user data processing:', error);
        throw error;
      }
    })
    .catch(error => {
      console.error('Login error:', error);
      // Do not retry with default password
      document.getElementById("loginError").textContent = "❌ " + error.message;
      const loginScreen = document.getElementById("loginScreen");
      if (loginScreen) loginScreen.style.opacity = "1";
    });
  } catch (error) {
    console.error('login: Outer try-catch error:', error);
    document.getElementById("loginError").textContent = "❌ " + error.message;
    const loginScreen = document.getElementById("loginScreen");
    if (loginScreen) loginScreen.style.opacity = "1";
  }
}

// Placeholder for setupInactivityTracking if not defined elsewhere
function setupInactivityTracking() {
  let inactivityTimeout;
  const TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes
  function resetTimer() {
    if (inactivityTimeout) clearTimeout(inactivityTimeout);
    inactivityTimeout = setTimeout(() => {
      alert('You have been logged out due to inactivity. Please log in again.');
      logout();
    }, TIMEOUT_MS);
  }
  // Listen for user activity
  ['mousemove', 'keydown', 'mousedown', 'touchstart'].forEach(evt => {
    window.addEventListener(evt, resetTimer, true);
  });
  resetTimer();
}

function logout() {
  // Log logout event before signing out
  if (auth.currentUser && auth.currentUser.email) {
    logUserEvent('logout', auth.currentUser.email);
  }
  auth.signOut().then(() => {
    window.location.reload();
  }).catch(error => {
    console.error('Logout error:', error);
    alert('Error during logout: ' + error.message);
  });
}

function setupUIForRole(role, adminPrivileges = null) {
  const isAdmin = role === 'admin';
  
  // Show/hide admin-only elements
  document.querySelectorAll('.admin-only').forEach(element => {
    element.style.display = isAdmin ? 'block' : 'none';
  });
  
  // Toolbar button group (non-admin)
  const toolbarContent = document.querySelector('.toolbar-content');
  if (toolbarContent) {
    const buttonGroups = toolbarContent.querySelectorAll('.button-group');
    if (buttonGroups.length > 1) {
      const mainGroup = buttonGroups[1];
      // Remove any previous operator-only logout button
      const oldLogout = mainGroup.querySelector('.toolbar-button.operator-logout');
      if (oldLogout) oldLogout.remove();
      // Remove Reset button for operators
      const resetBtn = mainGroup.querySelector('button[onclick="resetMap()"]');
      if (resetBtn && !isAdmin) resetBtn.remove();
      // Add Logout button for operators if not present
      if (!isAdmin && !mainGroup.querySelector('.toolbar-button.operator-logout')) {
        const logoutBtn = document.createElement('button');
        logoutBtn.className = 'toolbar-button operator-logout';
        logoutBtn.innerHTML = '🚪 Logout';
        logoutBtn.onclick = logout;
        mainGroup.appendChild(logoutBtn);
      }
      // If admin, ensure Reset is present and Logout is not duplicated
      if (isAdmin && !mainGroup.querySelector('button[onclick="resetMap()"]')) {
        const resetBtn = document.createElement('button');
        resetBtn.className = 'toolbar-button';
        resetBtn.setAttribute('onclick', 'resetMap()');
        resetBtn.innerHTML = '🔄 Reset';
        // Insert after Print button (first in group)
        const printBtn = mainGroup.querySelector('button[onclick="printMap()"]');
        if (printBtn && printBtn.nextSibling) {
          mainGroup.insertBefore(resetBtn, printBtn.nextSibling);
        } else {
          mainGroup.appendChild(resetBtn);
        }
      }
      // Remove operator logout for admin
      if (isAdmin) {
        const opLogout = mainGroup.querySelector('.toolbar-button.operator-logout');
        if (opLogout) opLogout.remove();
      }
    }
  }

  // Enable/disable functionality based on role
  if (isAdmin) {
    // Enable all functionality for admin
    document.querySelectorAll('button, select, input').forEach(element => {
      element.disabled = false;
    });
  } else {
    // Disable admin-only functionality
    document.querySelectorAll('.admin-only').forEach(element => {
      element.disabled = true;
    });
  }
}

// Initialize layer groups
window.dataLayers = {
  gullies: L.layerGroup(),
  playgrounds: L.layerGroup(),
  walkways: L.layerGroup(),
  signage: L.layerGroup(),
  lining: L.layerGroup()
};

// Add layer buttons to the bottom panel
function initMap() {
  console.log('initMap: --- Starting map initialization process ---');
  
  const mapDiv = document.getElementById('map');
  console.log('initMap: Map div element:', mapDiv); // Should show the actual DOM element
  // REMOVED: mapDiv.style.display = 'block'; // This is now handled in handleLoginSuccess
  console.log('initMap: Map div display is managed by handleLoginSuccess.');
  
  // Check if map instance already exists to prevent re-initialization issues
  if (window.map instanceof L.Map) {
    console.log('initMap: Map instance already exists. Removing existing map and recreating.');
    window.map.remove();
    window.map = null; // Clear reference
  }

  // Create map instance
  window.map = L.map('map', {
    center: [51.9, -8.5],
    zoom: 13,
    zoomControl: false,
    attributionControl: false
  });
  
  console.log('initMap: Map instance created:', window.map); // Should be a Leaflet Map object
  
  // Add the base layer
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 19
  }).addTo(window.map);
  
  console.log('initMap: Basemap layer added.'); 
  // Add zoom control
  L.control.zoom({
    position: 'topright'
  }).addTo(window.map);
  
  // Add attribution
  L.control.attribution({
    position: 'bottomright',
    prefix: false
  }).addTo(window.map);

  // Add gullies layer by default
  window.dataLayers.gullies.addTo(window.map);
  currentActiveLayer = 'gullies';

  // Force a map update after setup is complete
  window.map.invalidateSize();
  console.log('initMap: Map invalidated size at end of initMap.');
  
  // Explicitly set view to ensure full rendering
  window.map.setView([51.9, -8.5], 13); // Use the default center and zoom
  console.log('initMap: Map view explicitly set after invalidateSize.');

  // Initialize click handler for add mode
  window.map.on('mousemove', (e) => {
    if (addMode) {
      const tooltip = document.getElementById('add-tooltip') || createTooltip();
      tooltip.style.display = 'block';
      tooltip.style.left = (e.originalEvent.pageX + 10) + 'px';
      tooltip.style.top = (e.originalEvent.pageY + 10) + 'px';
      tooltip.textContent = `Lat: ${e.latlng.lat.toFixed(6)}, Lng: ${e.latlng.lng.toFixed(6)}`;
    } else {
      const tooltip = document.getElementById('add-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }
  });
  console.log('initMap: Click handler for add mode initialized.');
}

// Update the layer toggle function
function toggleLayer(layerName) {
  console.log('toggleLayer: Toggling layer:', layerName);
  if (window.dataLayers && window.dataLayers[layerName]) {
    const layer = window.dataLayers[layerName];
    const isVisible = window.map.hasLayer(layer);
    if (!isVisible) {
      // Add all markers for this layer to the map
      layer.addTo(window.map);
      if (layerName === 'gullies') {
        gullyData.forEach(g => {
          if (!window.map.hasLayer(g.marker)) {
            g.marker.addTo(window.map);
          }
        });
      }
      currentActiveLayer = layerName;
    } else {
      // Remove all markers for this layer from the map
      if (layerName === 'gullies') {
        gullyData.forEach(g => {
          if (window.map.hasLayer(g.marker)) {
            window.map.removeLayer(g.marker);
          }
        });
      }
      layer.removeFrom(window.map);
      if (currentActiveLayer === layerName) {
        currentActiveLayer = null;
      }
    }
    updateLayerButtonStates();
    // Update checkbox states in layer control popup if it's open
    updateLayerCheckboxStates();
  }
}

// Update button states in bottom panel
function updateLayerButtonStates() {
  const buttons = document.querySelectorAll('.layer-button');
  buttons.forEach(button => {
    const layerName = button.id.replace('Button', ''); // Get layer name from button ID
    const isVisible = window.dataLayers[layerName] && window.map.hasLayer(window.dataLayers[layerName]);
    button.classList.toggle('active', isVisible);

    // Update the checkbox state
    const checkbox = button.querySelector('input[type="checkbox"]');
    if (checkbox) {
      checkbox.checked = isVisible;
    }
  });
}

// Update loadGullyData function
function loadGullyData() {
  console.log('loadGullyData: Loading gully data...');
  
  // Clear existing data
  gullyData.length = 0;
  Object.values(window.dataLayers).forEach(layer => layer.clearLayers());
  
  // Load data for each layer type
  Object.keys(window.dataLayers).forEach(layerType => {
    console.log('loadGullyData: Loading data for layer:', layerType);
    db.ref(layerType).on('value', snapshot => {
      const data = snapshot.val() || {};
      
      Object.entries(data).forEach(([id, item]) => {
        if (item.location) {
          const marker = addGullyToMap(item.location, id, layerType, item.status || 'Unmarked');
          if (item.status) {
            updateMarkerStatus(marker, item.status, layerType);
          }
        }
      });
      
      // Update summary after loading data
      updateSummary();
      console.log(`loadGullyData: Loaded ${Object.keys(data).length} items for ${layerType}`);
    });
  });
}

function toggleToolbar() {
  const toolbar = document.getElementById('functionToolbar');
  const icon = document.getElementById('toolbarToggleIcon');
  toolbar.classList.toggle('minimized');
  icon.textContent = toolbar.classList.contains('minimized') ? '▲' : '▼';
}

function updateUserInfo(userData) {
  const userInitials = document.getElementById('userInitials');
  const userName = document.getElementById('userName');
  
  if (userData) {
    userInitials.textContent = userData.initials || userData.email.substring(0, 2).toUpperCase();
    userName.textContent = `${userData.name || userData.email.split('@')[0]} (${userData.role})`;
  }
}

// Update the login success handler
function handleLoginSuccess(userData) {
  console.log('handleLoginSuccess: Login successful, preparing map initialization...');
  console.log('handleLoginSuccess: Current window.map state before setTimeout:', window.map);

  // Hide login screen
  const loginScreen = document.getElementById('loginScreen');
  if (loginScreen) loginScreen.style.display = 'none';
  
  // Show toolbar
  const functionToolbar = document.getElementById('functionToolbar');
  if (functionToolbar) functionToolbar.style.display = 'block';
  
  // Make map container visible immediately
  const mapDiv = document.getElementById('map');
  mapDiv.style.display = 'block';
  console.log('handleLoginSuccess: Map div display set to block.');

  // Force browser reflow to ensure map div has correct dimensions before initMap
  void mapDiv.offsetWidth; // Accessing offsetWidth forces reflow
  console.log('handleLoginSuccess: Forced map div reflow.');

  // Update user info
  updateUserInfo(userData);
  setupUIForRole(userData.role, userData.adminPrivileges);
  
  console.log('handleLoginSuccess: Reached point before setTimeout.'); // New diagnostic log

  // Initialize map and load data after a short delay to ensure the map container is rendered
  setTimeout(() => {
    console.log('handleLoginSuccess: Inside setTimeout. Calling initMap...');
    const currentMapDiv = document.getElementById('map');
    console.log(`handleLoginSuccess: Map div dimensions before initMap: Width=${currentMapDiv.offsetWidth}, Height=${currentMapDiv.offsetHeight}`);
    initMap();
    // Load latest gully data from Firebase after map is ready
    loadGullyData();
    console.log('handleLoginSuccess: Map initialized and gully data loaded.');
    console.log('handleLoginSuccess: Map initialized. Waiting for user to load data.');
  }, 500);
  // Start inactivity tracking
  setupInactivityTracking();
  // Log login event
  logUserEvent('login', userData.email);
}

function getStatusColor(status) {
  const colors = {
    Clear: '#4CAF50',      // Green
    Blocked: '#FF9800',    // Orange
    Broken: '#f44336',     // Red
    Remediation: '#9C27B0', // Purple
    Replacement: '#795548', // Brown
    Unmarked: '#9E9E9E'    // Grey
  };
  return colors[status] || '#9E9E9E';
}

function getMarkerOptions(status) {
  const colors = {
    Clear: '#4CAF50',      // Green
    Blocked: '#FF9800',    // Orange
    Broken: '#f44336',     // Red
    Remediation: '#9C27B0', // Purple
    Replacement: '#795548', // Brown
    Unmarked: '#9E9E9E'    // Grey
  };
  
  return {
    radius: 6,
    fillColor: colors[status] || '#9E9E9E',
    color: '#000', // Always black border
    weight: 2,     // Thicker border
    opacity: 1,
    fillOpacity: 1 // Fully opaque
  };
}

// Define custom icons for each layer
const layerIcons = {
  gullies: null, // Use circleMarker for gullies to show status color
  playgrounds: L.divIcon({
    className: 'custom-marker-icon',
    html: `<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10,3 3,17 17,17" fill="#43a047" stroke="#222" stroke-width="2"/></svg>`,
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    popupAnchor: [0, -10]
  }),
  walkways: L.divIcon({
    className: 'custom-marker-icon',
    html: `<svg width="20" height="20" viewBox="0 0 20 20"><rect x="4" y="4" width="12" height="12" fill="#e53935" stroke="#222" stroke-width="2"/></svg>`,
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    popupAnchor: [0, -10]
  }),
  signage: L.divIcon({
    className: 'custom-marker-icon',
    html: `<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10,2 12,8 18,8 13,12 15,18 10,14 5,18 7,12 2,8 8,8" fill="#fbc02d" stroke="#222" stroke-width="2"/></svg>`,
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    popupAnchor: [0, -10]
  }),
  lining: L.divIcon({
    className: 'custom-marker-icon',
    html: `<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15 10a6 6 0 1 1-6-6a4 4 0 1 0 6 6z" fill="#333" stroke="#222" stroke-width="2"/></svg>`,
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    popupAnchor: [0, -10]
  })
};

function addGullyToMap(latlng, gullyId, layerType = 'gullies', status = 'Unmarked') {
    let marker;
    if (layerType === 'gullies') {
        marker = L.circleMarker([latlng.lat, latlng.lng], getMarkerOptions(status));
    } else if (layerIcons[layerType]) {
        marker = L.marker([latlng.lat, latlng.lng], { icon: layerIcons[layerType] });
    } else {
        marker = L.marker([latlng.lat, latlng.lng]); // fallback
    }
    // Add to the correct layer group
    if (window.dataLayers && window.dataLayers[layerType]) {
        window.dataLayers[layerType].addLayer(marker);
    } else {
        console.warn('Layer not found:', layerType);
        marker.addTo(window.map);
    }
    marker.on('click', function(e) {
        if (deleteMode) {
            handleGullyDelete(gullyId, marker, layerType);
        } else {
            currentMarker = marker;
            showInspectionPopup(marker, gullyId, latlng, layerType);
        }
    });
    marker.on('mouseover', function() {
        if (deleteMode && layerType === 'gullies') {
            marker.setStyle({ radius: 10, color: '#000', weight: 2 });
        }
    });
    marker.on('mouseout', function() {
        if (deleteMode && layerType === 'gullies') {
            marker.setStyle({ radius: 8, color: '#000', weight: 2 });
        } else if (layerType === 'gullies') {
            marker.setStyle({ radius: 6, color: '#000', weight: 2 });
        }
    });
    gullyData.push({ 
        marker, 
        id: gullyId, 
        layer: layerType,
        status: status
    });
    return marker;
}

// Add after the Firebase initialization
// const layers = {
//   gullies: L.layerGroup(),
//   signage: L.layerGroup(),
//   playgrounds: L.layerGroup(),
//   parks: L.layerGroup(),
//   walkways: L.layerGroup(),
//   lining: L.layerGroup()
// };

let currentActiveLayer = 'gullies';
let gullyData = [];
let currentMarker = null;
let currentInspectionPopup = null;
let deleteMode = false;
let editMode = false;

// Add a Set to track imported file names and GPS positions
let importedFiles = new Set();
let importedPositions = new Set();

// Add helper function to check for duplicate positions
function isDuplicatePosition(lat, lng, tolerance = 0.0001) { // tolerance is roughly 11 meters
    const positionKey = `${lat.toFixed(5)},${lng.toFixed(5)}`;
    if (importedPositions.has(positionKey)) {
        return true;
    }
    
    // Check nearby positions within tolerance
    for (const pos of importedPositions) {
        const [existingLat, existingLng] = pos.split(',').map(Number);
        const distance = Math.sqrt(
            Math.pow(existingLat - lat, 2) + 
            Math.pow(existingLng - lng, 2)
        );
        if (distance < tolerance) {
            return true;
        }
    }
    return false;
}

// Global import cancellation flag
window.importCancelled = false;

// Function to cancel import
function cancelImport() {
    window.importCancelled = true;
    console.log('Import cancelled by user');
    
    // Clean up progress modal
    try {
        const progressDiv = document.querySelector('.modal-backdrop-custom');
        if (progressDiv) progressDiv.remove();
    } catch (e) {}
    
    // Clear file input
    const fileInput = document.getElementById('importFile');
    if (fileInput) fileInput.value = '';
    
    alert('Import cancelled. Any partially imported data may need to be cleaned up.');
}

// Optimized handleImportFile function for reliable imports
async function handleImportFile(event) {
    if (!auth.currentUser || currentRole !== 'admin') {
        alert('Only administrators can import files');
        return;
    }

    const file = event.target.files[0];
    if (!file) return;

    // Check file size before processing
    const maxFileSize = 50 * 1024 * 1024; // 50MB
    if (file.size > maxFileSize) {
        alert(`File too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Please use a file smaller than 50MB.`);
        event.target.value = '';
        return;
    }

    let selectedLayer = currentActiveLayer; // Use currentActiveLayer
    if (!selectedLayer) {
      alert('Please select a layer (e.g., Gullies, Playgrounds) before importing data.');
      return;
    }

    // Check for duplicate file name
    if (importedFiles.has(file.name)) {
        alert('This file has already been imported. Please choose a different file or reset the map first.');
        event.target.value = '';
        return;
    }

    try {
        console.log('handleImportFile: Starting file import...');
        
        // Reset cancellation flag
        window.importCancelled = false;
        
        // Check if required libraries are loaded
        if (typeof toGeoJSON === 'undefined') {
            throw new Error('KML parsing library not loaded. Please refresh the page and try again.');
        }
        
        if (typeof JSZip === 'undefined') {
            throw new Error('ZIP processing library not loaded. Please refresh the page and try again.');
        }
        
        let geojson;
        const extension = file.name.split('.').pop().toLowerCase();

        // Enhanced progress modal with better UI
        const progressBackdrop = document.createElement('div');
        progressBackdrop.className = 'modal-backdrop-custom';
        const progressDiv = document.createElement('div');
        progressDiv.className = 'card shadow p-4 text-center';
        progressDiv.style.maxWidth = '400px';
        progressDiv.innerHTML = `
            <div class="spinner-border text-primary mb-3" role="status"><span class="visually-hidden">Loading...</span></div>
            <h5>Importing Features</h5>
            <div id="import-status">Processing file...</div>
            <div class="progress mt-3" style="height: 20px;">
                <div id="import-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                     role="progressbar" style="width: 0%">0%</div>
            </div>
            <div id="import-progress-text" class="mt-2">0/Unknown</div>
            <div id="import-speed" class="text-muted small mt-1"></div>
            <button id="cancel-import" class="btn btn-danger mt-3" onclick="cancelImport()">Cancel Import</button>
        `;
        progressBackdrop.appendChild(progressDiv);
        document.body.appendChild(progressBackdrop);

        // Parse file with timeout and error handling
        document.getElementById('import-status').textContent = 'Parsing file...';
        
        // Update progress bar to show parsing is happening
        const progressBar = document.getElementById('import-progress-bar');
        progressBar.style.width = '10%';
        progressBar.textContent = '10%';
        
        // Add timeout protection for file parsing (reduced for small files)
        const parseTimeout = file.size < 1024 * 1024 ? 15000 : 30000; // 15 seconds for files < 1MB, 30 seconds for larger files
        const parsePromise = new Promise(async (resolve, reject) => {
            try {
                if (extension === 'kml') {
                    console.log('handleImportFile: Parsing KML file...');
                    document.getElementById('import-status').textContent = 'Reading KML file...';
                    progressBar.style.width = '20%';
                    progressBar.textContent = '20%';
                    
                    const text = await file.text();
                    console.log('handleImportFile: File text loaded, length:', text.length);
                    
                    if (text.length > 50 * 1024 * 1024) { // 50MB limit
                        throw new Error('File too large. Please use a file smaller than 50MB.');
                    }
                    
                    // Quick validation for small files
                    if (text.length < 100) {
                        throw new Error('File appears to be empty or invalid. Please check your KML file.');
                    }
                    
                    document.getElementById('import-status').textContent = 'Parsing KML structure...';
                    progressBar.style.width = '40%';
                    progressBar.textContent = '40%';
                    
                    const kml = new DOMParser().parseFromString(text, 'text/xml');
                    console.log('handleImportFile: KML DOM parsed');
                    
                    if (kml.getElementsByTagName('parsererror').length > 0) {
                        throw new Error('Invalid KML file format. Please check your file.');
                    }
                    
                    document.getElementById('import-status').textContent = 'Converting to GeoJSON...';
                    progressBar.style.width = '60%';
                    progressBar.textContent = '60%';
                    
                    geojson = toGeoJSON.kml(kml);
                    console.log('handleImportFile: KML converted to GeoJSON');
                    
                } else if (extension === 'kmz') {
                    console.log('handleImportFile: Detected KMZ file, decompressing...');
                    document.getElementById('import-status').textContent = 'Decompressing KMZ file...';
                    progressBar.style.width = '30%';
                    progressBar.textContent = '30%';
                    
                    const zip = await JSZip.loadAsync(file);
                    console.log('handleImportFile: KMZ loaded');
                    
                    let kmlFile = null;
                    let kmlFileName = '';

                    // Find the KML file inside the KMZ (usually doc.kml or a .kml in the root)
                    zip.forEach((relativePath, zipEntry) => {
                        if (relativePath.toLowerCase().endsWith('.kml')) {
                            kmlFile = zipEntry;
                            kmlFileName = relativePath;
                            return false; // Stop iteration
                        }
                    });

                    if (!kmlFile) {
                        throw new Error('No KML file found inside the KMZ archive.');
                    }
                    
                    console.log('handleImportFile: Found KML file in KMZ:', kmlFileName);
                    document.getElementById('import-status').textContent = 'Extracting KML from KMZ...';
                    progressBar.style.width = '50%';
                    progressBar.textContent = '50%';
                    
                    const kmlText = await kmlFile.async('text');
                    console.log('handleImportFile: KML text extracted, length:', kmlText.length);
                    
                    document.getElementById('import-status').textContent = 'Parsing KML from KMZ...';
                    progressBar.style.width = '70%';
                    progressBar.textContent = '70%';
                    
                    const kml = new DOMParser().parseFromString(kmlText, 'text/xml');
                    console.log('handleImportFile: KML DOM parsed from KMZ');
                    
                    if (kml.getElementsByTagName('parsererror').length > 0) {
                        throw new Error('Invalid KML file format inside KMZ. Please check your file.');
                    }
                    
                    geojson = toGeoJSON.kml(kml);
                    console.log('handleImportFile: KMZ decompressed and KML parsed.');
                } else {
                    throw new Error('Unsupported file format. Please import .kml or .kmz files.');
                }
                
                resolve(geojson);
            } catch (error) {
                reject(error);
            }
        });

        // Add timeout
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('File parsing timed out. Please try with a smaller file or check your file format.')), parseTimeout);
        });

        // Race between parsing and timeout
        geojson = await Promise.race([parsePromise, timeoutPromise]);

        console.log('handleImportFile: Parsed GeoJSON:', geojson);

        if (!geojson || !geojson.features || !geojson.features.length) {
            alert('No valid features found in the imported file');
            return;
        }

        const totalFeatures = geojson.features.length;
        console.log(`handleImportFile: Processing ${totalFeatures} features`);

        // Filter valid features first
        document.getElementById('import-status').textContent = 'Validating features...';
        const validFeatures = [];
        for (const feature of geojson.features) {
            if (feature.geometry && feature.geometry.type === 'Point' && feature.geometry.coordinates) {
                const [lng, lat] = feature.geometry.coordinates;
                if (isValidCoordinate(lng, lat) && !isDuplicatePosition(lat, lng)) {
                    validFeatures.push({ feature, lat, lng });
                }
            }
        }

        console.log(`handleImportFile: ${validFeatures.length} valid features found out of ${totalFeatures}`);

        if (validFeatures.length === 0) {
            alert('No valid Point features to import. All positions were duplicates, invalid, or not Point geometry.');
            return;
        }

        // Optimized batch processing configuration for small files
        const BATCH_SIZE = validFeatures.length <= 100 ? 50 : 25; // Larger batches for small files
        const BATCH_DELAY = validFeatures.length <= 100 ? 50 : 100; // Faster for small files
        const IMPORT_TIMEOUT = 120000; // 2 minutes total timeout (reduced for small files)
        const timestamp = Date.now();
        const currentLayer = selectedLayer;

        let importCount = 0;
        let duplicateCount = totalFeatures - validFeatures.length;
        let skippedCount = 0;
        const startTime = Date.now();

        document.getElementById('import-status').textContent = 'Importing to database...';
        document.getElementById('import-progress-text').textContent = `0/${validFeatures.length}`;

        // Add overall timeout protection
        const importTimeout = setTimeout(() => {
            console.error('Import timeout reached');
            alert('Import timed out after 2 minutes. Please try again or check your connection.');
            // Clean up progress modal
            try {
                const progressDiv = document.querySelector('.modal-backdrop-custom');
                if (progressDiv) progressDiv.remove();
            } catch (e) {}
            return;
        }, IMPORT_TIMEOUT);

        try {
            // Use Firebase batch writes for better performance
            const batchRef = db.ref().child(currentLayer);
            const batchData = {};
            
            // Prepare all data first (much faster than individual writes)
            for (let i = 0; i < validFeatures.length; i++) {
                if (window.importCancelled) {
                    throw new Error('Import cancelled by user');
                }
                
                const { feature, lat, lng } = validFeatures[i];
                const id = `${currentLayer}_${timestamp}_${i}`;
                
                batchData[id] = {
                    location: { lat, lng },
                    status: 'Unmarked',
                    created: firebase.database.ServerValue.TIMESTAMP,
                    createdBy: auth.currentUser.uid,
                    sourceFile: file.name
                };
                
                importedPositions.add(`${lat.toFixed(5)},${lng.toFixed(5)}`);
                importCount++;
                
                // Update progress every 10 features for small files
                if (i % 10 === 0 || i === validFeatures.length - 1) {
                    const progress = Math.round((importCount / validFeatures.length) * 80); // Reserve 20% for marker creation
                    // Reuse existing progressBar variable
                    const progressText = document.getElementById('import-progress-text');
                    const speedText = document.getElementById('import-speed');
                    
                    progressBar.style.width = `${progress}%`;
                    progressBar.textContent = `${progress}%`;
                    progressText.textContent = `${importCount}/${validFeatures.length}`;
                    
                    // Calculate speed
                    const elapsed = (Date.now() - startTime) / 1000;
                    const speed = Math.round(importCount / elapsed);
                    speedText.textContent = `${speed} features/second`;
                    
                    document.getElementById('import-status').textContent = 
                        `Preparing data... (${importCount}/${validFeatures.length})`;
                    
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
            
            // Single batch write to Firebase (much faster than individual writes)
            document.getElementById('import-status').textContent = 'Saving to database...';
            // Reuse existing progressBar variable
            progressBar.style.width = '85%';
            progressBar.textContent = '85%';
            
            await batchRef.update(batchData);
            
            console.log(`handleImportFile: Successfully imported ${importCount} features in single batch`);
            
        } finally {
            // Clear timeout
            clearTimeout(importTimeout);
        }

        // Optimized marker creation for small files
        document.getElementById('import-status').textContent = 'Adding markers to map...';
        // Reuse the progressBar variable declared earlier
        progressBar = document.getElementById('import-progress-bar');
        progressBar.style.width = '90%';
        progressBar.textContent = '90%';
        
        // Create markers efficiently for small files
        const markerPromises = [];
        for (let i = 0; i < validFeatures.length; i++) {
            if (window.importCancelled) {
                throw new Error('Import cancelled by user');
            }
            
            const { lat, lng } = validFeatures[i];
            const id = `${currentLayer}_${timestamp}_${i}`;
            
            try {
                addGullyToMap({ lat, lng }, id, currentLayer);
                
                // Update progress every 20 markers for small files
                if (i % 20 === 0 || i === validFeatures.length - 1) {
                    const markerProgress = Math.round(((i + 1) / validFeatures.length) * 10) + 90;
                    progressBar.style.width = `${markerProgress}%`;
                    progressBar.textContent = `${markerProgress}%`;
                    
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
            } catch (error) {
                console.warn('Failed to add marker to map:', error);
                skippedCount++;
            }
        }

        // Remove progress indicator
        progressDiv.remove();
        progressBackdrop.remove();

        // Add file name to imported set
        importedFiles.add(file.name);
        
        console.log('handleImportFile: Import complete:', importCount, 'features imported,', duplicateCount, 'duplicates skipped,', skippedCount, 'failed');

        if (importCount > 0) {
            // Fit map to imported features
            const bounds = L.latLngBounds(Array.from(importedPositions).map(pos => {
                const [lat, lng] = pos.split(',').map(Number);
                return [lat, lng];
            }));
            if (bounds.isValid()) {
                window.map.fitBounds(bounds);
            }
            
            // Ensure the imported layer is visible on the map
            if (currentLayer && window.dataLayers[currentLayer] && !window.map.hasLayer(window.dataLayers[currentLayer])) {
                window.dataLayers[currentLayer].addTo(window.map);
                updateLayerButtonStates(); // Update the checkbox for the newly visible layer
            }
            
            // Force map to re-render to show new markers
            window.map.invalidateSize();
            console.log('handleImportFile: Map invalidated size after import.');
            
            const message = `Successfully imported ${importCount} features.\n${duplicateCount} duplicate positions were skipped.\n${skippedCount} features failed to import.\n\nImport completed in ${Math.round((Date.now() - startTime) / 1000)} seconds.`;
            alert(message);
        } else {
            alert('No valid Point features were imported. All positions were duplicates, invalid, or failed to import.');
        }
        
    } catch (error) {
        console.error('handleImportFile: Import error:', error);
        
        // Clean up progress modal
        try {
            const progressDiv = document.querySelector('.modal-backdrop-custom');
            if (progressDiv) {
                progressDiv.remove();
            }
        } catch (cleanupError) {
            console.warn('Error cleaning up progress modal:', cleanupError);
        }
        
        // Show detailed error message
        let errorMessage = 'Error importing file: ' + error.message;
        
        // Provide specific guidance for common errors
        if (error.message.includes('timeout')) {
            errorMessage += '\n\nTry:\n- Using a smaller file\n- Checking your internet connection\n- Ensuring the file is a valid KML/KMZ format';
        } else if (error.message.includes('too large')) {
            errorMessage += '\n\nTry:\n- Splitting your file into smaller parts\n- Compressing your KMZ file\n- Using a file under 50MB';
        } else if (error.message.includes('Invalid KML')) {
            errorMessage += '\n\nTry:\n- Opening the file in Google Earth to verify it works\n- Re-exporting from your source application\n- Checking for special characters in place names';
        }
        
        alert(errorMessage);
    } finally {
        // Clear the file input
        event.target.value = '';
    }
}

function isValidCoordinate(lng, lat) {
  return !isNaN(lng) && !isNaN(lat) && 
         lng >= -180 && lng <= 180 && 
         lat >= -90 && lat <= 90;
}

function capturePhoto() {
  try {
    const photoInput = document.getElementById('inspection-photo');
    // Create a temporary input for capturing photos
    const tempInput = document.createElement('input');
    tempInput.type = 'file';
    tempInput.accept = 'image/*';
    tempInput.capture = 'environment'; // Use the back camera
    
    // When a photo is selected, copy it to the main photo input
    tempInput.onchange = function() {
      if (this.files && this.files[0]) {
        photoInput.files = this.files;
      }
    };
    
    tempInput.click();
  } catch (error) {
    console.error('Error capturing photo:', error);
    alert('Error capturing photo. Please try again.');
  }
}

function updateMarkerStatus(marker, status, layerType) {
  const options = getMarkerOptions(status);
  // Only call setStyle if marker is a CircleMarker (gullies)
  if (layerType === 'gullies' && marker && typeof marker.setStyle === 'function') {
    marker.setStyle({
      fillColor: options.fillColor,
      color: '#000', // Always black border
      weight: 2,     // Thicker border
      fillOpacity: 1,
      opacity: 1
    });
  }
  // Update gullyData status
  const gullyIndex = gullyData.findIndex(g => g.marker === marker);
  if (gullyIndex !== -1) {
    gullyData[gullyIndex].status = status;
  }
  // Force summary update
  updateSummary();
}

async function viewGullyHistory(gullyId) {
  try {
    // Get history from both locations
    const [inspectionsSnapshot, historySnapshot] = await Promise.all([
      db.ref(`gullies/${gullyId}/inspections`).once('value'),
      db.ref(`gully_history/${gullyId}`).once('value')
    ]);
    
    // Combine and sort all inspections
    const allInspections = [];
    
    // Add inspections from main gully record
    if (inspectionsSnapshot.exists()) {
      Object.values(inspectionsSnapshot.val()).forEach(inspection => {
        allInspections.push(inspection);
      });
    }
    
    // Add inspections from history
    if (historySnapshot.exists()) {
      Object.values(historySnapshot.val()).forEach(inspection => {
        allInspections.push(inspection);
      });
    }
    
    // Sort by timestamp, most recent first
    allInspections.sort((a, b) => b.timestamp - a.timestamp);
    
    // Create history display
    const historyHtml = allInspections.map(inspection => {
      const date = new Date(inspection.timestamp).toLocaleString();
      const inspectorInfo = inspection.inspector || {};
      const inspectorName = inspectorInfo.name || 'Unknown';
      const inspectorInitials = inspectorInfo.initials || 'UN';
      const status = inspection.status || 'Unknown';
      const photoHtml = inspection.photoURL ? 
        `<br><a href="${inspection.photoURL}" target="_blank" style="color: blue;">📷 View Photo</a>` : '';
      
      return `
        <div style="border-bottom: 1px solid #ccc; margin-bottom: 10px; padding-bottom: 10px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <strong style="font-size: 1.1em;">${date}</strong>
            <div>
              <span style="background: #e0e0e0; padding: 2px 8px; border-radius: 4px; font-weight: bold;">${inspectorInitials}</span>
            </div>
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Inspector:</span> ${inspectorName}
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Status:</span> 
            <span style="color: ${getStatusColor(status)};">${status}</span>
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Comments:</span><br>
            ${inspection.comment || 'None'}
          </div>
          ${photoHtml}
        </div>
      `;
    }).join('');
    
    // Replace viewGullyHistory modal with Bootstrap modal
    // Create and show modal
    const historyBackdrop = document.createElement('div');
    historyBackdrop.className = 'modal-backdrop-custom';
    historyBackdrop.onclick = function(e) { if (e.target === historyBackdrop) historyBackdrop.remove(); };
    const modal = document.createElement('div');
    modal.className = 'card shadow p-4';
    modal.style.maxWidth = '600px';
    modal.style.maxHeight = '90vh';
    modal.style.overflowY = 'auto';
    modal.innerHTML = `
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h3 class="m-0">Inspection History</h3>
        <button class="btn btn-secondary" onclick="this.closest('.card').parentElement.remove()">✖ Close</button>
      </div>
      <div>${historyHtml || 'No inspection history available'}</div>
    `;
    historyBackdrop.appendChild(modal);
    document.body.appendChild(historyBackdrop);
    
  } catch (error) {
    console.error('viewGullyHistory: Error loading history:', error);
    alert('Error loading history: ' + error.message);
  }
}

// Initialize auth state listener
auth.onAuthStateChanged(user => {
  console.log('Auth state changed, user:', user); 
  if (user) {
    console.log('Auth state changed: User authenticated, getting user data...');
    db.ref('users/' + user.uid).once('value').then(snapshot => {
      const userData = snapshot.val();
      if (!userData) {
        console.error('Auth state changed: No user data found');
        // Show login screen if no user data
        const loginScreen = document.getElementById('loginScreen');
        const map = document.getElementById('map');
        const functionToolbar = document.getElementById('functionToolbar');
        const summary = document.getElementById('summary');
        
        if (loginScreen) loginScreen.style.display = 'flex';
        if (map) map.style.display = 'none';
        if (functionToolbar) functionToolbar.style.display = 'none';
        if (summary) summary.style.display = 'none';
        return;
      }
      console.log('Auth state changed: User data retrieved, handling login success...');
      handleLoginSuccess(userData);
      
      // Check map status after a moment
      setTimeout(checkMapStatus, 1000);
    }).catch(error => {
      console.error('Auth state changed: Error getting user data:', error);
      // Show login screen on error
      const loginScreen = document.getElementById('loginScreen');
      const map = document.getElementById('map');
      const functionToolbar = document.getElementById('functionToolbar');
      const summary = document.getElementById('summary');
      
      if (loginScreen) loginScreen.style.display = 'flex';
      if (map) map.style.display = 'none';
      if (functionToolbar) functionToolbar.style.display = 'none';
      if (summary) summary.style.display = 'none';
    });
  } else {
    console.log('Auth state changed: No user logged in, showing login screen');
    
    // Add null checks for DOM elements
    const loginScreen = document.getElementById('loginScreen');
    const map = document.getElementById('map');
    const functionToolbar = document.getElementById('functionToolbar');
    const summary = document.getElementById('summary');
    
    if (loginScreen) loginScreen.style.display = 'flex';
    if (map) map.style.display = 'none';
    if (functionToolbar) functionToolbar.style.display = 'none';
    if (summary) summary.style.display = 'none';
  }
});

// Update the summary display with descriptions
function updateSummary() {
  const counts = {
    'All': 0,
    'Clear': 0,
    'Blocked': 0,
    'Broken': 0,
    'Remediation': 0,
    'Replacement': 0,
    'Expired': 0,
    'Unmarked': 0
  };

  const descriptions = {
    'All': 'Total number of gullies in the system',
    'Clear': 'Gullies that are clean and functioning properly',
    'Blocked': 'Gullies that are obstructed and need cleaning',
    'Broken': 'Gullies that are damaged and not functioning',
    'Remediation': 'Gullies that require maintenance work',
    'Replacement': 'Gullies that need to be completely replaced',
    'Expired': 'Gullies that need immediate inspection',
    'Unmarked': 'Gullies that have not been inspected yet'
  };
  
  // Only count gullies in the 'gullies' layer
  gullyData.forEach(gully => {
    if (gully.layer === 'gullies') {
      counts['All']++;
      const status = gully.status || 'Unmarked';
      if (counts.hasOwnProperty(status)) {
        counts[status]++;
      }
    }
  });
  
  // Create filter dropdown HTML
  let filterHtml = `
    <div style="margin-bottom: 15px;">
      <div style="margin-bottom: 10px;"><strong>Filter Gullies</strong></div>
      <select id="filterStatus" onchange="filterByStatus()" style="width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
        <option value="All">Show All (${counts['All']})</option>
  `;
  
  // Add options for each status that has gullies
  Object.entries(counts).forEach(([status, count]) => {
    if (status !== 'All' && count > 0) {
      filterHtml += `<option value="${status}">${status} (${count})</option>`;
    }
  });
  
  filterHtml += `
      </select>
    </div>
  `;
  
  // Update summary display with descriptions
  let summaryHtml = '<div style="margin-bottom: 15px;"><strong>Gully Status Summary</strong></div>';
  Object.entries(counts).forEach(([status, count]) => {
    if (status === 'All' || count > 0) {
      const color = getStatusColor(status);
      summaryHtml += `
        <div style="margin: 8px 0;">
          <div style="display: flex; align-items: center;">
            <span style="display: inline-block; width: 12px; height: 12px; background: ${color}; border-radius: 50%; margin-right: 5px; border: 1px solid #000;"></span>
            <span style="flex: 1; font-weight: bold;">${status}: ${count}</span>
          </div>
          <div style="margin-left: 17px; font-size: 0.9em; color: #666;">
            ${descriptions[status]}
          </div>
        </div>
      `;
    }
  });
  
  const summaryContent = document.getElementById('summaryContent');
  if (summaryContent) {
    summaryContent.innerHTML = filterHtml + summaryHtml;
  }
  
  // Reapply current filter if exists
  const filterStatus = document.getElementById('filterStatus');
  if (filterStatus && filterStatus.value !== 'All') {
    filterByStatus();
  }
}

// Function to filter from summary popup
function filterFromSummary(status) {
  console.log('filterFromSummary: Filtering by status:', status);
  
  // Debug: Log all unique statuses in gullyData
  const uniqueStatuses = [...new Set(gullyData.filter(g => g.layer === 'gullies').map(g => g.status || 'Unmarked'))];
  console.log('filterFromSummary: Available statuses in gullyData:', uniqueStatuses);
  
  // Close the summary popup
  const backdrop = document.querySelector('.modal-backdrop-custom');
  if (backdrop) {
    backdrop.remove();
  }
  
  // Apply the filter
  applyStatusFilter(status);
  
  // Show a brief notification
  showFilterNotification(status);
}

// Function to apply status filter
function applyStatusFilter(selectedStatus) {
  console.log(`applyStatusFilter: Starting filter for status: ${selectedStatus}`);
  console.log(`applyStatusFilter: Total gullies in gullyData: ${gullyData.length}`);
  
  let visibleCount = 0;
  let hiddenCount = 0;
  
  // Process all gullies
  gullyData.forEach((gully, index) => {
    if (gully.layer === 'gullies' && gully.marker) {
      try {
        if (selectedStatus === 'All') {
          // Show all gullies
          if (typeof gully.marker.setOpacity === 'function') {
            gully.marker.setOpacity(1);
          }
          if (typeof gully.marker.setStyle === 'function') {
            gully.marker.setStyle({ opacity: 1, fillOpacity: 1 });
          }
          visibleCount++;
        } else {
          // Show only matching status
          if (gully.status === selectedStatus) {
            if (typeof gully.marker.setOpacity === 'function') {
              gully.marker.setOpacity(1);
            }
            if (typeof gully.marker.setStyle === 'function') {
              gully.marker.setStyle({ opacity: 1, fillOpacity: 1 });
            }
            visibleCount++;
          } else {
            // Hide non-matching gullies
            if (typeof gully.marker.setOpacity === 'function') {
              gully.marker.setOpacity(0.05); // Almost invisible
            }
            if (typeof gully.marker.setStyle === 'function') {
              gully.marker.setStyle({ opacity: 0.05, fillOpacity: 0.05 });
            }
            hiddenCount++;
          }
        }
      } catch (error) {
        console.warn(`Error processing gully ${index}:`, error);
      }
    }
  });
  
  // Update any existing filter dropdown
  const filterStatus = document.getElementById('filterStatus');
  if (filterStatus) {
    filterStatus.value = selectedStatus;
  }
  
  console.log(`applyStatusFilter: Filter complete. Visible: ${visibleCount}, Hidden: ${hiddenCount}`);
  
  // Check and log the actual filter state
  setTimeout(() => {
    checkFilterState();
  }, 100);
}

// Function to show filter notification
function showFilterNotification(status) {
  const notification = document.createElement('div');
  notification.className = 'alert alert-info';
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    min-width: 250px;
    padding: 10px 15px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  `;
  
  const filterText = status === 'All' ? 'All gullies' : `${status} gullies`;
  const clearButton = status !== 'All' ? '<button type="button" class="btn btn-sm btn-outline-secondary ms-2" onclick="clearFilter()">Clear Filter</button>' : '';
  
  notification.innerHTML = `
    <strong>Filter Applied:</strong> ${filterText}
    ${clearButton}
    <button type="button" class="btn-close ms-2" onclick="this.parentElement.remove()"></button>
  `;
  
  document.body.appendChild(notification);
  
  // Auto-remove after 5 seconds (increased time to allow for clear button)
  setTimeout(() => {
    if (notification.parentElement) {
      notification.remove();
    }
  }, 5000);
}

// Function to clear current filter
function clearFilter() {
  console.log('clearFilter: Clearing current filter');
  applyStatusFilter('All');
  showFilterNotification('All');
}

// Function to check current filter state
function checkFilterState() {
  const visibleGullies = gullyData.filter(g => 
    g.layer === 'gullies' && 
    g.marker && 
    (g.marker.options?.opacity > 0.5 || g.marker._opacity > 0.5)
  );
  
  const statusCounts = {};
  visibleGullies.forEach(g => {
    const status = g.status || 'Unmarked';
    statusCounts[status] = (statusCounts[status] || 0) + 1;
  });
  
  console.log('checkFilterState: Currently visible gullies by status:', statusCounts);
  return statusCounts;
}

// Update the filter functionality (for dropdown)
function filterByStatus() {
  const selectedStatus = document.getElementById('filterStatus').value;
  applyStatusFilter(selectedStatus);
}

// Fix the export CSV function
function exportData() {
  if (!auth.currentUser) {
    alert('Please log in to export data');
    return;
  }

  try {
    // Get all gully data from Firebase
    db.ref('gullies').once('value')
      .then(snapshot => {
        const data = snapshot.val() || {};
        
        // Prepare CSV headers
        let csvContent = 'ID,Latitude,Longitude,Status,Last Inspection,Inspector,Comments\n';
        
        // Process each gully
        Object.entries(data).forEach(([id, gully]) => {
          if (gully.location) {
            const lastInspection = gully.inspections ? 
              Object.values(gully.inspections).sort((a, b) => b.timestamp - a.timestamp)[0] : null;
            
            const row = [
              id,
              gully.location.lat,
              gully.location.lng,
              gully.status || 'Unmarked',
              lastInspection ? new Date(lastInspection.timestamp).toLocaleDateString() : 'Never',
              lastInspection ? lastInspection.inspector.name : 'None',
              lastInspection ? (lastInspection.comment || '').replace(/,/g, ';') : ''
            ];
            
            csvContent += row.join(',') + '\n';
          }
        });
        
        // Create and trigger download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute('href', url);
          link.setAttribute('download', `gully_data_${new Date().toISOString().split('T')[0]}.csv`);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      })
      .catch(error => {
        console.error('exportData: Export error:', error);
        alert('Error exporting data: ' + error.message);
      });
  } catch (error) {
    console.error('exportData: Export error:', error);
    alert('Error exporting data: ' + error.message);
  }
}

function resetMap() {
  console.log('resetMap: Starting map reset...');
  if (!auth.currentUser) {
    alert('You must be logged in to reset the map');
    return;
  }

  // Prompt for password before reset
  const password = prompt('Please enter your password to confirm map reset:');
  if (!password) {
    alert('Reset cancelled. Password is required.');
    return;
  }
  const email = auth.currentUser.email;
  const credential = firebase.auth.EmailAuthProvider.credential(email, password);
  auth.currentUser.reauthenticateWithCredential(credential)
    .then(() => {
      // Password correct, proceed with reset
      const confirmReset = confirm('Are you sure you want to reset the map? This will remove all gullies from the map.');
      if (!confirmReset) {
        return;
      }
      try {
        // Check if window.map is a valid Leaflet map object
        if (!(window.map instanceof L.Map)) {
            console.error('resetMap: window.map is not a valid Leaflet map object. This should not happen during a normal reset. If the map is truly invalid, it might indicate a deeper issue.');
            // initMap(); // Re-initialization removed to prevent full map reload on reset.
        }

        console.log('resetMap: window.map state before reset:', window.map);

        // Show loading spinner
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading-spinner';
        loadingDiv.innerHTML = `
          <div class="spinner"></div>
          <div>Resetting map...</div>
        `;
        document.body.appendChild(loadingDiv);

        // Default center coordinates for Cork City
        const defaultCenter = [51.9, -8.5];
        const defaultZoom = 13;
        
        // Clear all layers
        Object.values(window.dataLayers).forEach(layer => {
          console.log(`resetMap: Attempting to clear layer: ${layer.id || "unknown"}`);
          layer.clearLayers();
        });

        // Clear the gullyData array
        gullyData.length = 0;
        console.log('resetMap: Cleared gully data array');

        // Reset the map view with animation
        window.map.setView(defaultCenter, defaultZoom, {
          animate: true,
          duration: 1.0
        });
        console.log('resetMap: Map view reset.');

        // Reset any active filters
        const filterStatus = document.getElementById('filterStatus');
        if (filterStatus) {
          filterStatus.value = 'All';
          console.log('resetMap: Reset filter status');
        }

        // Clear file input
        const importFile = document.getElementById('importFile');
        if (importFile) {
          importFile.value = '';
          console.log('resetMap: Cleared file input');
        }

        // Clear any existing popups
        window.map.closePopup();
        console.log('resetMap: Closed existing popups.');
        
        // Remove any existing summary popups
        const existingSummary = document.querySelector('.summary-popup');
        if (existingSummary) {
          existingSummary.remove();
          console.log('resetMap: Removed summary popup.');
        }

        // Update summary if it exists
        if (typeof updateSummary === 'function') {
          updateSummary();
          console.log('resetMap: Updated summary.');
        }

        // Clear the sets of imported files and positions
        importedFiles.clear();
        importedPositions.clear();
        console.log('resetMap: Cleared imported files and positions sets.');

        // Remove loading spinner after a short delay
        setTimeout(() => {
          loadingDiv.remove();
          console.log('resetMap: Map reset complete.');
          alert('Map has been reset successfully');
        }, 1000);

      } catch (error) {
        console.error('resetMap: Error resetting map:', error);
        // Remove loading spinner if there's an error
        const loadingDiv = document.querySelector('.loading-spinner');
        if (loadingDiv) {
          loadingDiv.remove();
        }
        alert('Error resetting map: ' + error.message);
      }
    })
    .catch(error => {
      alert('Password incorrect. Map reset cancelled.');
    });
}

function showSummaryPopup() {
  // Calculate summary data
  const summary = {
    total: 0,
    Clear: 0,
    Blocked: 0,
    Broken: 0,
    Remediation: 0,
    Replacement: 0,
    Unmarked: 0
  };

  // Count gullies by status
  gullyData.forEach(gully => {
    if (gully.layer === 'gullies') {
      summary.total++;
      const status = gully.status || 'Unmarked';
      if (summary.hasOwnProperty(status)) {
        summary[status]++;
      }
    }
  });

  // Create popup HTML
  let html = `
    <div class="summary-header d-flex justify-content-between align-items-center mb-4">
      <div class="d-flex align-items-center">
        <i class="bi bi-bar-chart-fill text-primary me-2" style="font-size: 1.5rem;"></i>
        <h2 class="m-0 fw-bold">Gully Inspection Summary</h2>
      </div>
      <button class="btn btn-outline-secondary btn-sm" onclick="closeModal()" title="Close">
        <i class="bi bi-x-lg"></i>
      </button>
    </div>
    
    <div class="summary-content">
      <div class="mb-4">
        <button class="btn btn-primary w-100 py-2" onclick="filterFromSummary('All')">
          <i class="bi bi-eye-fill me-2"></i> Show All Gullies
        </button>
      </div>
      
      <div class="mb-4">
        <div class="status-card card p-3 text-center border-primary">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="bi bi-collection-fill text-primary me-2" style="font-size: 1.2rem;"></i>
            <h3 class="m-0 fw-bold">Total Gullies</h3>
          </div>
          <div class="status-count text-primary">${summary.total}</div>
          <div class="status-description text-muted">Total number of gullies in the system</div>
        </div>
      </div>
      <div class="status-grid">
        ${Object.entries(summary)
          .filter(([status]) => status !== 'total')
          .map(([status, count]) => `
            <div class="status-item">
              <div class="status-card card h-100 text-center" 
                   style="border-left: 4px solid ${getStatusColor(status)}; cursor: pointer; transition: all 0.3s ease;"
                   onclick="filterFromSummary('${status}')"
                   onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(0,0,0,0.15)'"
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                <div class="card-body p-3">
                  <div class="d-flex align-items-center justify-content-center mb-2">
                    <div class="status-icon me-2" style="background-color: ${getStatusColor(status)}; width: 12px; height: 12px; border-radius: 50%;"></div>
                    <h4 class="m-0 fw-bold">${status}</h4>
                  </div>
                  <div class="status-count fw-bold" style="color: ${getStatusColor(status)}; font-size: 1.5rem;">${count}</div>
                  <div class="status-description text-muted small mb-2">${{
                    Clear: 'Clean and functioning properly',
                    Blocked: 'Obstructed and need cleaning',
                    Broken: 'Damaged and not functioning',
                    Remediation: 'Require maintenance work',
                    Replacement: 'Need to be completely replaced',
                    Unmarked: 'Have not been inspected yet'
                  }[status] || ''}</div>
                  <div class="mt-auto">
                    <small class="text-primary fw-semibold">
                      <i class="bi bi-funnel me-1"></i>Click to filter
                    </small>
                  </div>
                </div>
              </div>
            </div>
          `).join('')}
      </div>
    </div>`;

  // Create backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop-custom';
  backdrop.onclick = function(e) {
    if (e.target === backdrop) backdrop.remove();
  };

  // Create modal
  const modal = document.createElement('div');
  modal.className = 'summary-popup';
  modal.innerHTML = html;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  // Close helper
  window.closeModal = () => backdrop.remove();
}

function showSearchPopup() {
  console.log('showSearchPopup: Opening search popup');
  
  // Remove any existing search popup
  const existingPopup = document.getElementById('searchPopupContainer');
  if (existingPopup) {
    existingPopup.remove();
  }
  
  // Create search popup container
  const container = document.createElement('div');
  container.id = 'searchPopupContainer';
  container.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.15);
    border: 1px solid #e0e0e0;
    z-index: 3001;
    font-family: 'Segoe UI', Arial, sans-serif;
    overflow: hidden;
  `;

  container.innerHTML = `
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px 20px; display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center;">
        <i class="bi bi-search" style="font-size: 1.2rem; margin-right: 12px;"></i>
        <span style="font-size: 1.1rem; font-weight: 600;">Search Assets</span>
      </div>
      <button onclick="document.getElementById('searchPopupContainer').remove()" style="background: none; border: none; color: white; font-size: 1.1rem; cursor: pointer;">
        <i class="bi bi-x-lg"></i>
      </button>
    </div>
    <div style="padding: 20px;">
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">Search for gullies, parks, or assets:</label>
        <div style="display: flex; gap: 8px;">
          <input type="text" id="searchInput" placeholder="Enter name, estate, or location..." 
                 style="flex: 1; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; outline: none;"
                 onkeyup="handleSearchInput(event)">
          <button onclick="performSearch()" style="padding: 12px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
            <i class="bi bi-search"></i> Search
          </button>
        </div>
      </div>
      
      <div id="searchResults" style="max-height: 400px; overflow-y: auto;">
        <div style="text-align: center; color: #6c757d; padding: 20px;">
          <i class="bi bi-search" style="font-size: 2rem; margin-bottom: 10px; display: block;"></i>
          Enter a search term to find gullies, parks, or other assets
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(container);
  
  // Focus on search input
  setTimeout(() => {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }, 100);
}

function handleSearchInput(event) {
  if (event.key === 'Enter') {
    performSearch();
  }
}

function performSearch() {
  const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
  const resultsContainer = document.getElementById('searchResults');
  
  if (!searchTerm) {
    resultsContainer.innerHTML = `
      <div style="text-align: center; color: #6c757d; padding: 20px;">
        <i class="bi bi-search" style="font-size: 2rem; margin-bottom: 10px; display: block;"></i>
        Enter a search term to find gullies, parks, or other assets
      </div>
    `;
    return;
  }
  
  console.log('performSearch: Searching for:', searchTerm);
  
  // Search through gully data
  const results = [];
  
  if (window.gullyData && Array.isArray(window.gullyData)) {
    window.gullyData.forEach((gully, index) => {
      const searchableText = [
        gully.name || '',
        gully.estate || '',
        gully.location || '',
        gully.description || '',
        gully.status || '',
        gully.layer || ''
      ].join(' ').toLowerCase();
      
      if (searchableText.includes(searchTerm)) {
        results.push({
          type: 'gully',
          data: gully,
          index: index,
          matchText: gully.name || gully.estate || 'Unnamed Gully'
        });
      }
    });
  }
  
  // Display results
  if (results.length === 0) {
    resultsContainer.innerHTML = `
      <div style="text-align: center; color: #6c757d; padding: 20px;">
        <i class="bi bi-exclamation-circle" style="font-size: 2rem; margin-bottom: 10px; display: block;"></i>
        No results found for "${searchTerm}"
        <br><small>Try searching for a different term</small>
      </div>
    `;
  } else {
    const resultsHTML = results.map(result => `
      <div onclick="zoomToAsset('${result.type}', ${result.index})" 
           style="display: flex; align-items: center; padding: 12px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef; transition: all 0.2s ease;"
           onmouseover="this.style.background='#e9ecef'"
           onmouseout="this.style.background='#f8f9fa'">
        <div style="width: 24px; height: 24px; background: #2196F3; border-radius: 6px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
          <i class="bi bi-geo-alt-fill" style="color: white; font-size: 0.8rem;"></i>
        </div>
        <div style="flex: 1;">
          <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">${result.matchText}</div>
          <div style="font-size: 0.8rem; color: #6c757d;">
            ${result.data.estate ? 'Estate: ' + result.data.estate : ''} 
            ${result.data.status ? '• Status: ' + result.data.status : ''}
            ${result.data.layer ? '• Type: ' + result.data.layer : ''}
          </div>
        </div>
        <div style="color: #6c757d; font-size: 0.9rem;">
          <i class="bi bi-arrow-right"></i>
        </div>
      </div>
    `).join('');
    
    resultsContainer.innerHTML = `
      <div style="margin-bottom: 12px; padding: 8px 12px; background: #e3f2fd; border-radius: 6px; border-left: 4px solid #2196F3;">
        <strong>${results.length}</strong> result${results.length === 1 ? '' : 's'} found
      </div>
      ${resultsHTML}
    `;
  }
}

function zoomToAsset(type, index) {
  console.log('zoomToAsset: Zooming to', type, 'at index', index);
  
  if (type === 'gully' && window.gullyData && window.gullyData[index]) {
    const gully = window.gullyData[index];
    
    if (gully.lat && gully.lng) {
      // Close search popup
      const searchPopup = document.getElementById('searchPopupContainer');
      if (searchPopup) {
        searchPopup.remove();
      }
      
      // Zoom to the gully location
      window.map.setView([gully.lat, gully.lng], 18);
      
      // Highlight the gully marker if it exists
      if (gully.marker) {
        // Flash the marker
        const originalStyle = gully.marker.options;
        gully.marker.setStyle({
          radius: 12,
          weight: 3,
          color: '#ff0000',
          fillColor: '#ff0000',
          fillOpacity: 0.8
        });
        
        setTimeout(() => {
          if (gully.marker) {
            gully.marker.setStyle(originalStyle);
          }
        }, 3000);
      }
      
      // Show a brief notification
      showNotification(`Zoomed to ${gully.name || 'Gully'}`, 'success');
    } else {
      showNotification('Location data not available for this asset', 'error');
    }
  }
}

function showNotification(message, type = 'info') {
  // Remove any existing notifications
  const existingNotification = document.getElementById('notification');
  if (existingNotification) {
    existingNotification.remove();
  }
  
  const notification = document.createElement('div');
  notification.id = 'notification';
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 8px;
    color: white;
    font-weight: 600;
    z-index: 3002;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transition: all 0.3s ease;
  `;
  
  // Set color based on type
  switch (type) {
    case 'success':
      notification.style.background = '#4CAF50';
      break;
    case 'error':
      notification.style.background = '#F44336';
      break;
    case 'warning':
      notification.style.background = '#FF9800';
      break;
    default:
      notification.style.background = '#2196F3';
  }
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Auto-remove after 3 seconds
  setTimeout(() => {
    if (notification.parentNode) {
      notification.remove();
    }
  }, 3000);
}

// Update the window.onload to include new initialization
window.onload = () => {
  const loginScreen = document.getElementById("loginScreen");
  if (loginScreen) loginScreen.style.display = "block";
  
  // Initialize users
  Promise.all([
    ensureAllUsers()
  ]).then(() => {
    console.log('window.onload: User system initialized');
    // Handle auto-login after initialization
    handleAutoLogin();
  }).catch(error => {
    console.error('window.onload: Error during initialization:', error);
  });
};

function togglePassword() {
  const passwordInput = document.getElementById('password');
  const icon = document.getElementById('passwordToggleIcon');
  if (passwordInput.type === 'password') {
    passwordInput.type = 'text';
    if (icon) { icon.classList.remove('bi-eye'); icon.classList.add('bi-eye-slash'); }
  } else {
    passwordInput.type = 'password';
    if (icon) { icon.classList.remove('bi-eye-slash'); icon.classList.add('bi-eye'); }
  }
}

// Load saved email on page load (only if no URL parameters)
window.addEventListener('load', function() {
  const urlParams = new URLSearchParams(window.location.search);
  const emailFromUrl = urlParams.get('email');
  
  // Only load saved email if no email is provided in URL
  if (!emailFromUrl) {
    const savedEmail = localStorage.getItem('rememberedEmail');
    if (savedEmail) {
      document.getElementById('email').value = savedEmail;
      document.getElementById('rememberMe').checked = true;
    }
  }
});

function printMap() {
  window.print();
}

function updateWelcomeMessage(email) {
  const welcomeDiv = document.getElementById('welcomeMessage');
  if (welcomeDiv) {
    welcomeDiv.textContent = `Welcome ${email.split('@')[0]}!`;
    welcomeDiv.style.padding = '10px';
    welcomeDiv.style.background = 'white';
    welcomeDiv.style.borderRadius = '4px';
    welcomeDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    welcomeDiv.style.position = 'absolute';
    welcomeDiv.style.top = '10px';
    welcomeDiv.style.right = '10px';
    welcomeDiv.style.zIndex = '1000';
    welcomeDiv.style.display = 'block';
  }
}

// Update scale control
function updateScaleControl() {
  if (window.map.scale) window.map.scale.remove();
  
  window.map.scale = L.control.scale({
    metric: true,
    imperial: false,
    maxWidth: 200,
    position: 'bottomleft',
    updateWhenIdle: true
  }).addTo(window.map);
  
  // Custom scale factor to correct the scale
  const scaleFactor = 0.333333; // 1km = 3000m correction
  
  const originalGetScaleText = window.map.scale._getScaleText;
  window.map.scale._getScaleText = function(ratio, text) {
    const distance = ratio * scaleFactor;
    if (distance >= 1) {
      return distance.toFixed(0) + ' km';
    } else {
      return (distance * 1000).toFixed(0) + ' m';
    }
  };
}

function toggleFunctionTabs() {
  const tabs = document.getElementById('functionTabs');
  const icon = document.getElementById('tabToggleIcon');
  tabs.classList.toggle('minimized');
  icon.textContent = tabs.classList.contains('minimized') ? '▲' : '▼';
}

// Add a function to check map status
function checkMapStatus() {
  console.log('checkMapStatus: Map container:', document.getElementById('map'));
  console.log('checkMapStatus: Map instance:', window.map);
  if (window.map instanceof L.Map) {
    console.log('checkMapStatus: Map center:', window.map.getCenter());
    console.log('checkMapStatus: Map zoom:', window.map.getZoom());
  } else {
    console.warn('checkMapStatus: window.map is not a Leaflet map instance.');
  }
}

// Add a function to check if map needs reset
function checkMapState() {
  if (gullyData.length > 0) {
    const resetButton = document.querySelector('button[onclick="resetMap()"]');
    if (resetButton) {
      resetButton.style.backgroundColor = '#ff9800';
      resetButton.style.color = 'white';
      setTimeout(() => {
        resetButton.style.backgroundColor = '';
        resetButton.style.color = '';
      }, 2000);
    }
  }
}

// Add the delete and edit functions
function enableDeleteMode() {
    if (!auth.currentUser || currentRole !== 'admin') {
        alert('Only administrators can delete gullies');
        return;
    }
    deleteMode = !deleteMode;
    editMode = false;
    const mapElement = document.getElementById('map');
    const deleteButton = document.querySelector('button[onclick="enableDeleteMode()"]');
    if (deleteMode) {
        mapElement.style.cursor = 'pointer';
        deleteButton.style.backgroundColor = '#ff4444';
        deleteButton.style.color = 'white';
        alert('Delete mode enabled. Click on gullies to delete them.');
    } else {
        mapElement.style.cursor = '';
        deleteButton.style.backgroundColor = '';
        deleteButton.style.color = '';
    }
    gullyData.forEach(gully => {
        if (gully.marker) {
            if (deleteMode) {
                gully.marker.setStyle({ radius: 8, color: '#000', weight: 2 });
            } else {
                gully.marker.setStyle({ radius: 6, color: '#000', weight: 2 });
            }
        }
    });
}

function enableEditMode() {
    if (!auth.currentUser || currentRole !== 'admin') {
        alert('Only administrators can edit gullies');
        return;
    }
    
    editMode = !editMode;
    deleteMode = false;
    
    const editButton = document.querySelector('button[onclick="enableEditMode()"]');
    if (editButton) {
        if (editMode) {
            editButton.style.backgroundColor = '#2196F3';
            editButton.style.color = 'white';
            alert('Edit mode enabled. Click on gullies to edit them.');
        } else {
            editButton.style.backgroundColor = '';
            editButton.style.color = '';
        }
    }
}

async function handleGullyDelete(gullyId, marker, layerType) {
    if (!deleteMode || !auth.currentUser || currentRole !== 'admin') return;
    try {
        const confirmDelete = confirm('Are you sure you want to delete this gully?');
        if (!confirmDelete) return;
        marker.setStyle({ fillColor: '#ff0000', radius: 8, color: '#000', weight: 2 });
        // Remove from Firebase
        await db.ref(`${layerType}/${gullyId}`).remove();
        // Remove from map layer
        if (window.dataLayers && window.dataLayers[layerType]) {
            window.dataLayers[layerType].removeLayer(marker);
        }
        // Remove from gullyData array
        const index = gullyData.findIndex(g => g.id === gullyId);
        if (index !== -1) {
            gullyData.splice(index, 1);
        }
        updateSummary();
        // Remove marker from map if still present
        if (window.map.hasLayer(marker)) {
            window.map.removeLayer(marker);
        }
        enableDeleteMode(); // Disable delete mode after successful deletion
    } catch (error) {
        console.error('handleGullyDelete: Error deleting gully:', error);
        alert('Error deleting gully: ' + error.message);
        if (marker) {
            marker.setStyle(getMarkerOptions('Unmarked'));
        }
    }
}

// Add the new mode variable
let addMode = false;

// Add the new functions
function enableAddMode() {
    if (!auth.currentUser || currentRole !== 'admin') {
        alert('Only administrators can add new gullies');
        return;
    }
    
    addMode = !addMode;
    editMode = false;
    deleteMode = false;
    
    // Update cursor and button style
    const mapElement = document.getElementById('map');
    const addButton = document.querySelector('button[onclick="enableAddMode()"]');
    
    if (addMode) {
        mapElement.style.cursor = 'crosshair';
        addButton.style.backgroundColor = '#4CAF50';
        addButton.style.color = 'white';
        alert('Add mode enabled. Click on the map to add new asset.');
        // Add click handler to map
        window.map.on('click', handleMapClick);
    } else {
        mapElement.style.cursor = '';
        addButton.style.backgroundColor = '';
        addButton.style.color = '';
        
        // Remove click handler from map
        window.map.off('click', handleMapClick);
    }
}

async function handleMapClick(e) {
    if (!addMode || !auth.currentUser || currentRole !== 'admin') return;
    
    try {
        const timestamp = Date.now();
        // Ensure 'activeLayer' is correctly referenced or replaced if it's from a removed dropdown
        // For now, using 'gullies' as a default if activeLayer is not available
        const currentLayer = currentActiveLayer || 'gullies'; 
        const newId = `${currentLayer}_${timestamp}`;
        const latlng = e.latlng;
        
        console.log('handleMapClick: Adding new gully at:', latlng);
        
        // Add marker to map
        const marker = addGullyToMap(latlng, newId, currentLayer);
        
        // Save to Firebase
        await db.ref(`${currentLayer}/${newId}`).set({
            location: { 
                lat: latlng.lat, 
                lng: latlng.lng 
            },
            status: 'Unmarked',
            created: firebase.database.ServerValue.TIMESTAMP,
            createdBy: auth.currentUser.uid
        });
        
        console.log('handleMapClick: New gully added successfully');
        
        // Show inspection popup immediately
        currentMarker = marker;
        showInspectionPopup(marker, newId, latlng, currentLayer);
        
        // Disable add mode after successful addition
        enableAddMode();
        
    } catch (error) {
        console.error('handleMapClick: Error adding new gully:', error);
        alert('Error adding new gully: ' + error.message);
    }
}

// Helper function to create tooltip
function createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'add-tooltip';
    tooltip.style.cssText = `
        position: fixed;
        background: white;
        padding: 5px 10px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        pointer-events: none;
        font-size: 12px;
    `;
    document.body.appendChild(tooltip);
    return tooltip;
}

// 1. Backup function
function saveGullyData() {
  if (!auth.currentUser) {
    alert('Please log in to back up data');
    return;
  }
  const layersToBackup = ['gullies', 'signage', 'playgrounds', 'parks', 'walkways', 'lining'];
  const backup = {};
  let completed = 0;
  layersToBackup.forEach(layer => {
    db.ref(layer).once('value').then(snapshot => {
      backup[layer] = snapshot.val() || {};
      completed++;
      if (completed === layersToBackup.length) {
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `gully_backup_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        alert('Backup downloaded successfully!');
      }
    }).catch(error => {
      alert('Error backing up ' + layer + ': ' + error.message);
    });
  });
}

// 2. User management modal
function showUserManagement() {
  if (!auth.currentUser) {
    alert('Only administrators can view users');
    return;
  }
  db.ref('users').once('value').then(snapshot => {
    const users = snapshot.val() || {};
    let html = `<div style="max-height:60vh;overflow:auto;">
      <h3>User Management</h3>
      <table class='table table-striped table-bordered'>
        <tr><th>User</th><th>Role</th></tr>`;
    Object.values(users).forEach(user => {
      html += `<tr><td>${user.name ? user.name + ' ' : ''}(${user.email || ''})</td><td>${user.role || ''}</td></tr>`;
    });
    html += '</table>';
    html += `<div class='text-end mt-3'><button class='btn btn-secondary' onclick='closeModal()'>Close</button></div></div>`;

    // Create backdrop
    const backdrop = document.createElement('div');
    backdrop.className = 'modal-backdrop-custom';
    backdrop.onclick = function(e) {
      if (e.target === backdrop) backdrop.remove();
    };

    // Create modal
    const modal = document.createElement('div');
    modal.className = 'user-management-modal card shadow p-4';
    modal.innerHTML = html;
    modal.style.maxWidth = '98vw';
    modal.style.maxHeight = '90vh';
    modal.style.overflow = 'auto';

    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);

    // Close helper
    window.closeModal = () => backdrop.remove();
  });
}

// Layer management
let mapLayers = {
  gullies: { visible: true, data: null },
  playgrounds: { visible: false, data: null },
  walkways: { visible: false, data: null },
  signage: { visible: false, data: null },
  lining: { visible: false, data: null }
};

function toggleLayer(layerName) {
  console.log('toggleLayer: Toggling layer:', layerName);
  
  if (window.dataLayers && window.dataLayers[layerName]) {
    const layer = window.dataLayers[layerName];
    const isVisible = window.map.hasLayer(layer);
    
    // Toggle the clicked layer
    if (!isVisible) {
      layer.addTo(window.map);
      currentActiveLayer = layerName;
    } else {
      layer.removeFrom(window.map);
      if (currentActiveLayer === layerName) {
        currentActiveLayer = null;
      }
    }
    
    // Update visual state of buttons
    updateLayerButtonStates();
  }
}

function showLayerControl() {
  console.log('showLayerControl: Attempting to show layer control.');
  
  // Remove any existing layer control first
  const existingControl = document.getElementById('layerControlContainer');
  if (existingControl) {
    existingControl.remove();
  }
  
  // Create a new layer control with guaranteed visibility
  const container = document.createElement('div');
  container.id = 'layerControlContainer';
  container.className = 'layer-control-card';
  container.style.cssText = `
    position: absolute;
    left: 24px;
    top: 24px;
    z-index: 3000;
    min-width: 320px;
    max-width: 380px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.15);
    border: 1px solid #e0e0e0;
    background: white;
    padding: 0;
    margin: 0;
    font-family: 'Segoe UI', Arial, sans-serif;
    display: block;
  `;

  // Create the layer list HTML
  const layerListHTML = `
    <div class="layer-item" onclick="toggleLayer('gullies')" style="display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef;">
      <div style="margin-right: 12px;">
        <input class="form-check-input" type="checkbox" id="gulliesLayer" onclick="event.stopPropagation(); toggleLayer('gullies')" ${window.map && window.dataLayers.gullies && window.map.hasLayer(window.dataLayers.gullies) ? 'checked' : ''} style="width: 18px; height: 18px;">
      </div>
      <div style="margin-right: 12px; width: 24px; height: 24px; background: #2196F3; border-radius: 6px; border: 2px solid #1976D2;"></div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">Gullies</div>
        <div style="font-size: 0.8rem; color: #6c757d;">Drainage inspection points</div>
      </div>
    </div>
    
    <div class="layer-item" onclick="toggleLayer('playgrounds')" style="display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef;">
      <div style="margin-right: 12px;">
        <input class="form-check-input" type="checkbox" id="playgroundsLayer" onclick="event.stopPropagation(); toggleLayer('playgrounds')" ${window.map && window.dataLayers.playgrounds && window.map.hasLayer(window.dataLayers.playgrounds) ? 'checked' : ''} style="width: 18px; height: 18px;">
      </div>
      <div style="margin-right: 12px; width: 24px; height: 24px; background: #4CAF50; border-radius: 6px; border: 2px solid #388E3C;"></div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">Playgrounds</div>
        <div style="font-size: 0.8rem; color: #6c757d;">Recreational areas</div>
      </div>
    </div>
    
    <div class="layer-item" onclick="toggleLayer('walkways')" style="display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef;">
      <div style="margin-right: 12px;">
        <input class="form-check-input" type="checkbox" id="walkwaysLayer" onclick="event.stopPropagation(); toggleLayer('walkways')" ${window.map && window.dataLayers.walkways && window.map.hasLayer(window.dataLayers.walkways) ? 'checked' : ''} style="width: 18px; height: 18px;">
      </div>
      <div style="margin-right: 12px; width: 24px; height: 24px; background: #F44336; border-radius: 6px; border: 2px solid #D32F2F;"></div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">Walkways</div>
        <div style="font-size: 0.8rem; color: #6c757d;">Pedestrian paths</div>
      </div>
    </div>
    
    <div class="layer-item" onclick="toggleLayer('signage')" style="display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef;">
      <div style="margin-right: 12px;">
        <input class="form-check-input" type="checkbox" id="signageLayer" onclick="event.stopPropagation(); toggleLayer('signage')" ${window.map && window.dataLayers.signage && window.map.hasLayer(window.dataLayers.signage) ? 'checked' : ''} style="width: 18px; height: 18px;">
      </div>
      <div style="margin-right: 12px; width: 24px; height: 24px; background: #FF9800; border-radius: 6px; border: 2px solid #F57C00;"></div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">Signage</div>
        <div style="font-size: 0.8rem; color: #6c757d;">Information signs</div>
      </div>
    </div>
    
    <div class="layer-item" onclick="toggleLayer('lining')" style="display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; margin: 4px 0; background: #f8f9fa; border: 1px solid #e9ecef;">
      <div style="margin-right: 12px;">
        <input class="form-check-input" type="checkbox" id="liningLayer" onclick="event.stopPropagation(); toggleLayer('lining')" ${window.map && window.dataLayers.lining && window.map.hasLayer(window.dataLayers.lining) ? 'checked' : ''} style="width: 18px; height: 18px;">
      </div>
      <div style="margin-right: 12px; width: 24px; height: 24px; background: #9C27B0; border-radius: 6px; border: 2px solid #7B1FA2;"></div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #2c3e50; font-size: 0.95rem; margin-bottom: 2px;">Road Lining</div>
        <div style="font-size: 0.8rem; color: #6c757d;">Road markings</div>
      </div>
    </div>
  `;

  container.innerHTML = `
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px 20px; display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center; flex: 1;">
        <div style="color: rgba(255,255,255,0.8); font-size: 1.2rem; cursor: move; margin-right: 12px;">
          <i class="bi bi-grip-vertical"></i>
        </div>
        <div style="display: flex; align-items: center; font-size: 1.1rem; font-weight: 600;">
          <i class="bi bi-layers-fill me-2"></i>
          <span>Map Layers</span>
        </div>
      </div>
      <button type="button" onclick="document.getElementById('layerControlContainer').style.display='none'" style="background: none; border: none; color: rgba(255,255,255,0.8); font-size: 1.1rem; cursor: pointer; padding: 4px; border-radius: 4px;">
        <i class="bi bi-x-lg"></i>
      </button>
    </div>
    <div style="padding: 20px;">
      <div style="margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #f0f0f0;">
        <small style="color: #6c757d;">Select which layers to display on the map</small>
      </div>
      <div style="display: flex; flex-direction: column; gap: 8px;">
        ${layerListHTML}
      </div>
    </div>
  `;

  document.body.appendChild(container);
  console.log('showLayerControl: New layer control created and added to DOM');
  
  // Update checkbox states after creating the layer control
  updateLayerCheckboxStates();
}

// Function to update checkbox states in the layer control
function updateLayerCheckboxStates() {
  const layers = ['gullies', 'playgrounds', 'walkways', 'signage', 'lining'];
  layers.forEach(layerName => {
    const checkbox = document.getElementById(`${layerName}Layer`);
    if (checkbox && window.dataLayers && window.dataLayers[layerName]) {
      const isVisible = window.map.hasLayer(window.dataLayers[layerName]);
      checkbox.checked = isVisible;
      console.log(`updateLayerCheckboxStates: ${layerName} checkbox set to ${isVisible}`);
    }
  });
}

function createLayerControlContainer() {
  const container = document.createElement('div');
  container.id = 'layerControlContainer';
  container.className = 'layer-control-card card shadow';
  container.style.display = 'block';

  // Build the layer list HTML
  let layerListHTML = '';
  const layers = [
    { key: 'gullies', name: 'Gullies', desc: 'Drainage inspection points', iconClass: 'gully-icon' },
    { key: 'playgrounds', name: 'Playgrounds', desc: 'Recreational areas', iconClass: 'playground-icon' },
    { key: 'walkways', name: 'Walkways', desc: 'Pedestrian paths', iconClass: 'walkway-icon' },
    { key: 'signage', name: 'Signage', desc: 'Information signs', iconClass: 'signage-icon' },
    { key: 'lining', name: 'Road Lining', desc: 'Road markings', iconClass: 'lining-icon' }
  ];
  layers.forEach(layer => {
    layerListHTML += `
      <div class="layer-item" onclick="toggleLayer('${layer.key}')">
        <div class="layer-checkbox">
          <input class="form-check-input" type="checkbox" id="${layer.key}Layer" ${window.map && window.dataLayers[layer.key] && window.map.hasLayer(window.dataLayers[layer.key]) ? 'checked' : ''}>
        </div>
        <div class="layer-icon-container">
          <div class="layer-icon ${layer.iconClass}"></div>
        </div>
        <div class="layer-info">
          <div class="layer-name">${layer.name}</div>
          <div class="layer-description">${layer.desc}</div>
        </div>
      </div>
    `;
  });

  if (!layerListHTML) {
    layerListHTML = `<div class="text-muted text-center py-3">No layers available</div>`;
  }

  container.innerHTML = `
    <div class="layer-header">
      <div class="layer-header-content">
        <div class="drag-handle" title="Drag to move">
          <i class="bi bi-grip-vertical"></i>
        </div>
        <div class="layer-title">
          <i class="bi bi-layers-fill me-2"></i>
          <span>Map Layers</span>
        </div>
      </div>
      <button type="button" class="layer-close-btn" aria-label="Close" id="closeLayerControlBtn">
        <i class="bi bi-x-lg"></i>
      </button>
    </div>
    <div class="layer-content">
      <div class="layer-description">
        <small class="text-muted">Select which layers to display on the map</small>
      </div>
      <div class="layer-list">
        ${layerListHTML}
      </div>
    </div>
  `;

  document.body.appendChild(container);
  updateLayerButtonStates();
  setTimeout(() => {
    const closeBtn = document.getElementById('closeLayerControlBtn');
    if (closeBtn) {
      closeBtn.onclick = function() {
        container.style.display = 'none';
      };
    }
    makeLayerControlDraggable();
  }, 0);
}

function toggleLayerControl() {
  console.log('toggleLayerControl: Toggling layer control visibility.');
  const container = document.getElementById('layerControlContainer');
  const content = container.querySelector('.layer-content');
  const icon = container.querySelector('.collapse-icon');
  
  content.classList.toggle('expanded');
  icon.classList.toggle('expanded');
  console.log('toggleLayerControl: Layer control expanded state:', content.classList.contains('expanded'));
}

// Initialize layer visibility on startup
function initializeLayerVisibility() {
  console.log('initializeLayerVisibility: Initializing layer visibility.');

  // Clear all layers from the map first to prevent duplicates during re-initialization
  Object.values(window.dataLayers).forEach(layer => {
    if (window.map.hasLayer(layer)) {
      window.map.removeLayer(layer);
    }
  });

  // Add layers to the map if they contain any features
  Object.keys(window.dataLayers).forEach(layerName => {
    if (window.dataLayers[layerName] && window.dataLayers[layerName].getLayers().length > 0) {
      window.dataLayers[layerName].addTo(window.map);
      console.log(`initializeLayerVisibility: Added ${layerName} to map because it contains data.`);
    } else if (layerName === 'gullies') {
      // Ensure gullies layer is always on the map, even if empty, as it's the default active layer.
      window.dataLayers[layerName].addTo(window.map);
      console.log(`initializeLayerVisibility: Added empty ${layerName} to map as default.`);
    }
  });

  // Set the currentActiveLayer based on what's visible, or default to 'gullies'
  let foundActive = false;
  for (const layerName in window.dataLayers) {
    if (window.map.hasLayer(window.dataLayers[layerName])) {
      currentActiveLayer = layerName;
      foundActive = true;
      break;
    }
  }
  if (!foundActive) {
    currentActiveLayer = 'gullies'; // Fallback if no layers have data or are visible
  }

  updateLayerButtonStates(); // Ensure visual state is accurate
  updateLayerCheckboxStates(); // Update checkbox states in layer control
  console.log('initializeLayerVisibility: Layer button states updated.');
}

// Remove the old layer control div if it still exists from previous versions
document.querySelector('.layer-control')?.remove();

// Add a form submit handler to always call login()
document.addEventListener('DOMContentLoaded', function() {
  var loginForm = document.getElementById('loginForm');
  if (loginForm) {
    loginForm.addEventListener('submit', function(e) {
      e.preventDefault();
      login();
      return false;
    });
  }
});

// Add after updateMarkerStatus or near other popup/inspection functions
function showInspectionPopup(marker, gullyId, latlng, layerType) {
  // Custom popup for playgrounds and walkways
  if (layerType === 'playgrounds' || layerType === 'walkways') {
    db.ref(`${layerType}/${gullyId}`).once('value').then(snapshot => {
      const asset = snapshot.val() || {};
      const description = asset.description || 'No description';
      const status = asset.status || '';
      const comment = asset.comment || '';
      const photoURL = asset.photoURL || '';
      const date = asset.date ? new Date(asset.date).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
      const canEdit = (window.currentUserData && (window.currentUserData.role === 'admin' || window.currentUserData.role === 'operator')) || editMode;
      let html = `<form id='asset-inspection-form'>`;
      html += `<div class='inspection-popup popup-form'>`;
      html += `<h3 style='margin-top:0;'>${layerType.charAt(0).toUpperCase() + layerType.slice(1)} Asset</h3>`;
      html += `<div><b>Description:</b> ${description}</div>`;
      html += `<div><b>Status:</b> <select id='asset-status'>`;
      html += `<option value='Fixed'${status === 'Fixed' ? ' selected' : ''}>Fixed</option>`;
      html += `<option value='Replaced'${status === 'Replaced' ? ' selected' : ''}>Replaced</option>`;
      html += `<option value='New Installation'${status === 'New Installation' ? ' selected' : ''}>New Installation</option>`;
      html += `</select></div>`;
      // Always show date picker, disabled if not editable
      html += `<div><b>Date:</b><br/><input type='date' id='asset-date' value='${date}' style='width:100%;margin-bottom:5px;' ${canEdit ? '' : 'disabled'}></div>`;
      html += `<div><b>Comment:</b><br/>`;
      html += `<input type='text' id='asset-comment' placeholder='Enter comment' style='width:100%;margin-bottom:5px;' value="${comment || ''}" ${canEdit ? '' : 'readonly'}>`;
      html += `</div>`;
      html += `<div><b>Photo:</b><br/>`;
      if (photoURL) {
        html += `<a href='${photoURL}' target='_blank' style='color:blue;'>📷 View Photo</a><br/>`;
        html += `<img src='${photoURL}' alt='Asset Photo' style='max-width:100%;max-height:100px;margin:5px 0;display:block;'>`;
      }
      if (canEdit) {
        html += `<input type='file' id='asset-photo' accept='image/*' style='margin-top:5px;display:none;'/><br/>`;
        html += `<button id='take-photo-btn' type='button' style='margin:5px 0;'>📸 Take Photo</button>`;
        html += `<img id='asset-photo-preview' style='max-width:100%;max-height:100px;display:none;margin:5px 0;'>`;
      }
      html += `</div>`;
      if (canEdit) {
        html += `<div style='margin-top:8px;display:flex;align-items:center;gap:8px;'>`;
        html += `<input type='checkbox' id='confirm-save-asset' style='margin-right:4px;'>`;
        html += `<label for='confirm-save-asset' style='margin:0;'>Confirm Save</label>`;
        html += `<button id='save-asset' style='margin-left:8px;' disabled>Save</button>`;
        html += `</div>`;
      }
      html += `<div class='d-flex gap-2 justify-content-end mt-3'>`;
      if (canEdit) {
        html += `<button id='save-asset' class='btn btn-success flex-fill' type='button' disabled>Save</button>`;
      }
      html += `<button id='view-history' class='btn btn-outline-secondary flex-fill' type='button'>View History</button>`;
      html += `</div>`;
      html += `</div>`;
      html += `</form>`;
      // Remove any existing modal
      document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
      const inspectionBackdrop = document.createElement('div');
      inspectionBackdrop.className = 'modal-backdrop-custom';
      inspectionBackdrop.onclick = function(e) { if (e.target === inspectionBackdrop) inspectionBackdrop.remove(); };
      const modal = document.createElement('div');
      modal.className = 'card shadow p-4';
      modal.style.maxWidth = '400px';
      modal.style.maxHeight = '90vh';
      modal.style.overflowY = 'auto';
      modal.innerHTML = `
        <div class=\"d-flex justify-content-between align-items-center mb-3\">\n        <h3 class=\"m-0\">${layerType === 'gullies' ? 'Gully Inspection' : layerType.charAt(0).toUpperCase() + layerType.slice(1) + ' Asset'}</h3>\n        <button class=\"btn btn-secondary\" onclick=\"this.closest('.card').parentElement.remove()\">✖ Close</button>\n      </div>\n      <div>${html}</div>\n    `;
      inspectionBackdrop.appendChild(modal);
      document.body.appendChild(inspectionBackdrop);
      setTimeout(() => {
        if (canEdit) {
          // Photo preview logic
          const photoInput = document.getElementById('asset-photo');
          const photoPreview = document.getElementById('asset-photo-preview');
          if (photoInput && photoPreview) {
            photoInput.onchange = function() {
              if (photoInput.files && photoInput.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                  photoPreview.src = e.target.result;
                  photoPreview.style.display = 'block';
                };
                reader.readAsDataURL(photoInput.files[0]);
              } else {
                photoPreview.style.display = 'none';
              }
            };
          }
          // Take Photo button
          const takePhotoBtn = document.getElementById('take-photo-btn');
          if (takePhotoBtn && photoInput) {
            takePhotoBtn.onclick = function() {
              photoInput.setAttribute('capture', 'environment');
              photoInput.click();
            };
          }
          // Confirm Save checkbox
          const confirmSave = document.getElementById('confirm-save-asset');
          const saveBtn = document.getElementById('save-asset');
          if (confirmSave && saveBtn) {
            confirmSave.onchange = function() {
              saveBtn.disabled = !confirmSave.checked;
            };
            saveBtn.disabled = !confirmSave.checked;
          }
          // Save logic
          if (saveBtn) {
            saveBtn.onclick = async function() {
              if (saveBtn.disabled) return;
              try {
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;
                const newStatus = document.getElementById('asset-status').value;
                const newComment = document.getElementById('asset-comment').value;
                const newDate = document.getElementById('asset-date').value;
                let newPhotoURL = photoURL;
                if (photoInput && photoInput.files && photoInput.files[0]) {
                  const file = photoInput.files[0];
                  const storageRef = storage.ref(`${layerType}/${gullyId}/${Date.now()}_${file.name}`);
                  await storageRef.put(file);
                  newPhotoURL = await storageRef.getDownloadURL();
                }
                await db.ref(`${layerType}/${gullyId}`).update({
                  status: newStatus,
                  comment: newComment,
                  date: newDate,
                  photoURL: newPhotoURL
                });
                alert('Asset updated!');
                window.map.closePopup(currentInspectionPopup);
              } catch (err) {
                alert('Error saving asset: ' + err.message);
                saveBtn.textContent = 'Save';
                saveBtn.disabled = false;
              }
            };
          }
        }
      }, 100);
    });
    return; // Prevent running the gully popup code
  }
  if (currentInspectionPopup) {
    window.map.closePopup(currentInspectionPopup);
    currentInspectionPopup = null;
  }
  db.ref(`${layerType}/${gullyId}`).once('value').then(snapshot => {
    const gully = snapshot.val() || {};
    const status = gully.status || 'Unmarked';
    const lastInspection = gully.inspections ?
      Object.values(gully.inspections).sort((a, b) => b.timestamp - a.timestamp)[0] : null;
    const comment = lastInspection ? lastInspection.comment : '';
    const photoURL = lastInspection ? lastInspection.photoURL : '';
    const inspector = lastInspection && lastInspection.inspector ? lastInspection.inspector.name : '';
    const timestamp = lastInspection ? lastInspection.timestamp : null;
    const canEdit = (window.currentUserData && (window.currentUserData.role === 'admin' || window.currentUserData.role === 'operator')) || editMode;
    // Date picker setup
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    let lastDate = timestamp ? new Date(timestamp).toISOString().split('T')[0] : todayStr;
    // Build the modal content
    let html = `<form id='gully-inspection-form' class='needs-validation' novalidate>`;
    // Editable ID for admin only
    if (canEdit && window.currentUserData && window.currentUserData.role === 'admin') {
      html += `<div class='mb-2'><label class='form-label'><b>ID:</b></label> <input type='text' id='gully-id-edit' class='form-control' value='${gullyId}'></div>`;
    } else {
      html += `<div class='mb-2'><label class='form-label'><b>ID:</b></label> <span>${gullyId}</span></div>`;
    }
    // Date picker
    if (canEdit) {
      // Add time input next to date input
      let lastTime = '12:00';
      if (timestamp) {
        const d = new Date(timestamp);
        lastTime = d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0');
      } else {
        const now = new Date();
        lastTime = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
      }
      html += `<div class='mb-2'><label class='form-label'><b>Inspection Date & Time:</b></label><div style='display:flex;gap:8px;'><input type='date' id='inspection-date' class='form-control' max='${todayStr}' value='${lastDate}' required><input type='time' id='inspection-time' class='form-control' value='${lastTime}' required></div></div>`;
    } else {
      let timeStr = '12:00';
      if (timestamp) {
        const d = new Date(timestamp);
        timeStr = d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0');
      }
      html += `<div class='mb-2'><label class='form-label'><b>Inspection Date & Time:</b></label> <span>${lastDate} ${timeStr}</span></div>`;
    }
    // Comment textarea
    if (canEdit) {
      html += `<div class='mb-2'><label class='form-label'><b>Comment:</b></label><textarea id='inspection-comment-custom' class='form-control' placeholder='Enter comment'>${comment || ''}</textarea></div>`;
    } else {
      html += `<div class='mb-2'><label class='form-label'><b>Comment:</b></label> <div class='form-control-plaintext' style='min-height:2em;'>${comment || '-'}</div></div>`;
    }
    // --- PHOTO UPLOAD/TAKE PHOTO/PREVIEW ---
    if (canEdit) {
      html += `<div class='mb-2'><label class='form-label'><b>Photo:</b></label><br/>`;
      if (photoURL) {
        html += `<a href='${photoURL}' target='_blank' style='color:blue;'>📷 View Photo</a><br/>`;
        html += `<img src='${photoURL}' alt='Inspection Photo' style='max-width:100%;max-height:100px;margin:5px 0;display:block;'>`;
      }
      html += `<input type='file' id='inspection-photo' accept='image/*' style='margin-top:5px;display:none;'/><br/>`;
      html += `<button id='take-photo-btn' type='button' style='margin:5px 0;'>📸 Take Photo</button>`;
      html += `<img id='inspection-photo-preview' style='max-width:100%;max-height:100px;display:none;margin:5px 0;'>`;
      html += `<div id='photo-upload-progress-container' style='display:none;margin:5px 0;'>`
      html += `<div style='width:100%;background:#eee;border-radius:4px;overflow:hidden;height:16px;'>`
      html += `<div id='photo-upload-progress-bar' style='width:0%;height:16px;background:#2196F3;transition:width 0.2s;'></div>`
      html += `</div>`
      html += `<div id='photo-upload-progress-text' style='font-size:12px;text-align:center;margin-top:2px;'></div>`
      html += `</div>`;
    } else if (photoURL) {
      html += `<div class='mb-2'><label class='form-label'><b>Photo:</b></label><br/>`;
      html += `<a href='${photoURL}' target='_blank' style='color:blue;'>📷 View Photo</a><br/>`;
      html += `<img src='${photoURL}' alt='Inspection Photo' style='max-width:100%;max-height:100px;margin:5px 0;display:block;'>`;
      html += `</div>`;
    }
    // Status dropdown for editable gullies
    if (canEdit) {
      html += `<div class='mb-2'><label class='form-label'><b>Status:</b></label><select id='inspection-status' class='form-select'>`;
      const statuses = ['Clear','Blocked','Broken','Remediation','Replacement','Unmarked'];
      statuses.forEach(s => {
        html += `<option value='${s}'${status === s ? ' selected' : ''}>${s}</option>`;
      });
      html += `</select></div>`;
    } else {
      html += `<div class='mb-2'><label class='form-label'><b>Status:</b></label> <span>${status}</span></div>`;
    }
    // Confirm inspection checkbox and Save button
    if (canEdit) {
      html += `<div class='form-check mb-2'>`;
      html += `<input type='checkbox' class='form-check-input' id='confirm-save-inspection'>`;
      html += `<label class='form-check-label' for='confirm-save-inspection'>Confirm Inspection</label>`;
      html += `</div>`;
      html += `<div class='d-flex gap-2 justify-content-end mt-3'>`;
      html += `<button id='save-inspection' class='btn btn-success flex-fill' type='button' disabled>Save Inspection</button>`;
      html += `<button id='view-history' class='btn btn-outline-secondary flex-fill' type='button'>View History</button>`;
      html += `</div>`;
    } else {
      html += `<div class='d-flex gap-2 justify-content-end mt-3'>`;
      html += `<button id='view-history' class='btn btn-outline-secondary flex-fill' type='button'>View History</button>`;
      html += `</div>`;
    }
    html += `</form>`;
    // Remove any existing modal
    document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
    const inspectionBackdrop = document.createElement('div');
    inspectionBackdrop.className = 'modal-backdrop-custom';
    inspectionBackdrop.onclick = function(e) { if (e.target === inspectionBackdrop) inspectionBackdrop.remove(); };
    const modal = document.createElement('div');
    modal.className = 'card shadow p-4';
    modal.style.maxWidth = '400px';
    modal.style.maxHeight = '90vh';
    modal.style.overflowY = 'auto';
    modal.innerHTML = `
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h3 class="m-0">${layerType === 'gullies' ? 'Gully Inspection' : layerType.charAt(0).toUpperCase() + layerType.slice(1) + ' Asset'}</h3>
        <button class="btn btn-secondary" onclick="this.closest('.card').parentElement.remove()">✖ Close</button>
      </div>
      <div>${html}</div>
    `;
    inspectionBackdrop.appendChild(modal);
    document.body.appendChild(inspectionBackdrop);
    // Re-attach event handlers as before (photo preview, save, etc.)
    setTimeout(() => {
      if (canEdit) {
        // Photo preview logic
        const photoInput = document.getElementById('inspection-photo');
        const photoPreview = document.getElementById('inspection-photo-preview');
        const takePhotoBtn = document.getElementById('take-photo-btn');
        if (photoInput && photoPreview) {
          photoInput.onchange = function() {
            if (photoInput.files && photoInput.files[0]) {
              const reader = new FileReader();
              reader.onload = function(e) {
                photoPreview.src = e.target.result;
                photoPreview.style.display = 'block';
              };
              reader.readAsDataURL(photoInput.files[0]);
            } else {
              photoPreview.style.display = 'none';
            }
          };
        }
        if (takePhotoBtn && photoInput) {
          takePhotoBtn.onclick = function() {
            photoInput.setAttribute('capture', 'environment');
            photoInput.click();
          };
        }
        // Confirm Save Inspection checkbox
        const confirmSave = document.getElementById('confirm-save-inspection');
        const saveBtn = document.getElementById('save-inspection');
        if (!saveBtn) {
          console.error('Save Inspection button not found in popup!');
          return;
        }
        if (confirmSave) {
          confirmSave.onchange = function() {
            saveBtn.disabled = !confirmSave.checked;
          };
          saveBtn.disabled = !confirmSave.checked;
        } else {
          saveBtn.disabled = false;
        }
        saveBtn.onclick = async function() {
          if (saveBtn.disabled) return;
          try {
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            // Robustly get values, fallback if missing
            const statusInput = document.getElementById('inspection-status');
            const newStatus = statusInput ? statusInput.value : (gully.status || 'Unmarked');
            const commentCustom = document.getElementById('inspection-comment-custom');
            const newComment = commentCustom ? commentCustom.value : '';
            const dateInput = document.getElementById('inspection-date');
            const timeInput = document.getElementById('inspection-time');
            let inspectionTimestamp = Date.now();
            if (dateInput && dateInput.value && timeInput && timeInput.value) {
              // Combine selected date and selected time
              const [year, month, day] = dateInput.value.split('-');
              const [hour, minute] = timeInput.value.split(':');
              const dateWithTime = new Date(
                Number(year),
                Number(month) - 1,
                Number(day),
                Number(hour),
                Number(minute),
                0,
                0
              );
              inspectionTimestamp = dateWithTime.getTime();
            }
            let newPhotoURL = photoURL;
            if (photoInput && photoInput.files && photoInput.files[0]) {
              const file = photoInput.files[0];
              const storageRef = storage.ref(`inspections/${gullyId}/${Date.now()}_${file.name}`);
              // Show progress bar at upload start
              const progressContainer = document.getElementById('photo-upload-progress-container');
              const progressBar = document.getElementById('photo-upload-progress-bar');
              const progressText = document.getElementById('photo-upload-progress-text');
              if (progressContainer && progressBar && progressText) {
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressText.textContent = 'Uploading photo...';
              }
              const uploadTask = storageRef.put(file);
              uploadTask.on('state_changed', function(snapshot) {
                const percent = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100);
                if (progressBar) progressBar.style.width = percent + '%';
                if (progressText) progressText.textContent = `Uploading photo... ${percent}%`;
              });
              const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Photo upload timed out after 2 minutes')), 120000));
              await Promise.race([
                uploadTask,
                timeoutPromise
              ]);
              newPhotoURL = await storageRef.getDownloadURL();
              if (progressContainer && progressBar && progressText) {
                progressBar.style.width = '100%';
                progressText.textContent = 'Upload complete!';
                setTimeout(() => { progressContainer.style.display = 'none'; }, 1000);
              }
            }
            await db.ref(`${layerType}/${gullyId}`).update({
              status: newStatus,
              comment: newComment,
              date: newDate,
              photoURL: newPhotoURL
            });
            alert('Inspection saved!');
            inspectionBackdrop.remove();
          } catch (err) {
            // Hide progress bar on error
            const progressContainer = document.getElementById('photo-upload-progress-container');
            if (progressContainer) progressContainer.style.display = 'none';
            alert('Error saving inspection: ' + err.message);
            saveBtn.textContent = 'Save Inspection';
            saveBtn.disabled = false;
          }
        };
      }
      document.getElementById('view-history').onclick = function() {
        viewGullyHistory(gullyId);
      };
    }, 100);
  });

  // Custom popup for signage
  if (layerType === 'signage') {
    db.ref(`${layerType}/${gullyId}`).once('value').then(snapshot => {
      const asset = snapshot.val() || {};
      const description = asset.description || 'No description';
      const status = asset.status || '';
      const comment = asset.comment || '';
      const photoURL = asset.photoURL || '';
      const date = asset.date ? new Date(asset.date).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
      const canEdit = (window.currentUserData && (window.currentUserData.role === 'admin' || window.currentUserData.role === 'operator')) || editMode;
      let html = `<div class='inspection-popup popup-form'>`;
      html += `<h3 style='margin-top:0;'>Signage Asset</h3>`;
      html += `<div><b>Description:</b> ${description}</div>`;
      html += `<div><b>Status:</b> <select id='signage-status'>`;
      html += `<option value='Replacement'${status === 'Replacement' ? ' selected' : ''}>Replacement</option>`;
      html += `<option value='New'${status === 'New' ? ' selected' : ''}>New</option>`;
      html += `<option value='Retired'${status === 'Retired' ? ' selected' : ''}>Retired</option>`;
      html += `<option value='Changed'${status === 'Changed' ? ' selected' : ''}>Changed</option>`;
      html += `</select></div>`;
      html += `<div><b>Date:</b><br/><input type='date' id='signage-date' value='${date}' style='width:100%;margin-bottom:5px;'></div>`;
      html += `<div><b>Comment:</b><br/>`;
      html += `<input type='text' id='signage-comment' placeholder='Enter comment' style='width:100%;margin-bottom:5px;' value="${comment || ''}">`;
      html += `</div>`;
      html += `<div><b>Photo:</b><br/>`;
      if (photoURL) {
        html += `<a href='${photoURL}' target='_blank' style='color:blue;'>📷 View Photo</a><br/>`;
        html += `<img src='${photoURL}' alt='Signage Photo' style='max-width:100%;max-height:100px;margin:5px 0;display:block;'>`;
      }
      if (canEdit) {
        html += `<input type='file' id='signage-photo' accept='image/*' style='margin-top:5px;display:none;'/><br/>`;
        html += `<button id='take-photo-btn' type='button' style='margin:5px 0;'>📸 Take Photo</button>`;
        html += `<img id='signage-photo-preview' style='max-width:100%;max-height:100px;display:none;margin:5px 0;'>`;
      }
      html += `</div>`;
      if (canEdit) {
        html += `<div style='margin-top:8px;display:flex;align-items:center;gap:8px;'>`;
        html += `<input type='checkbox' id='confirm-save-signage' style='margin-right:4px;'>`;
        html += `<label for='confirm-save-signage' style='margin:0;'>Confirm Save</label>`;
        html += `<button id='save-signage' style='margin-left:8px;' disabled>Save</button>`;
        html += `</div>`;
      }
      html += `<div class='d-flex gap-2 justify-content-end mt-3'>`;
      if (canEdit) {
        html += `<button id='save-signage' class='btn btn-success flex-fill' type='button' disabled>Save</button>`;
      }
      html += `<button id='view-history' class='btn btn-outline-secondary flex-fill' type='button'>View History</button>`;
      html += `</div>`;
      html += `</div>`;
      // Remove any existing modal
      document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
      const inspectionBackdrop = document.createElement('div');
      inspectionBackdrop.className = 'modal-backdrop-custom';
      inspectionBackdrop.onclick = function(e) { if (e.target === inspectionBackdrop) inspectionBackdrop.remove(); };
      const modal = document.createElement('div');
      modal.className = 'card shadow p-4';
      modal.style.maxWidth = '400px';
      modal.style.maxHeight = '90vh';
      modal.style.overflowY = 'auto';
      modal.innerHTML = `
        <div class="d-flex justify-content-between align-items-center mb-3">
          <h3 class="m-0">Signage Asset</h3>
          <button class="btn btn-secondary" onclick="this.closest('.card').parentElement.remove()">✖ Close</button>
        </div>
        <div>${html}</div>
      `;
      inspectionBackdrop.appendChild(modal);
      document.body.appendChild(inspectionBackdrop);
      // Re-attach event handlers as before (photo preview, save, etc.)
      setTimeout(() => {
        if (canEdit) {
          // Photo preview logic
          const photoInput = document.getElementById('signage-photo');
          const photoPreview = document.getElementById('signage-photo-preview');
          if (photoInput && photoPreview) {
            photoInput.onchange = function() {
              if (photoInput.files && photoInput.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                  photoPreview.src = e.target.result;
                  photoPreview.style.display = 'block';
                };
                reader.readAsDataURL(photoInput.files[0]);
              } else {
                photoPreview.style.display = 'none';
              }
            };
          }
          // Take Photo button
          const takePhotoBtn = document.getElementById('take-photo-btn');
          if (takePhotoBtn && photoInput) {
            takePhotoBtn.onclick = function() {
              photoInput.setAttribute('capture', 'environment');
              photoInput.click();
            };
          }
          // Confirm Save checkbox
          const confirmSave = document.getElementById('confirm-save-signage');
          const saveBtn = document.getElementById('save-signage');
          if (confirmSave && saveBtn) {
            confirmSave.onchange = function() {
              saveBtn.disabled = !confirmSave.checked;
            };
            saveBtn.disabled = !confirmSave.checked;
          }
          // Save logic
          if (saveBtn) {
            saveBtn.onclick = async function() {
              if (saveBtn.disabled) return;
              try {
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;
                const newStatus = document.getElementById('signage-status').value;
                const newComment = document.getElementById('signage-comment').value;
                const newDate = document.getElementById('signage-date').value;
                let newPhotoURL = photoURL;
                if (photoInput && photoInput.files && photoInput.files[0]) {
                  const file = photoInput.files[0];
                  const storageRef = storage.ref(`${layerType}/${gullyId}/${Date.now()}_${file.name}`);
                  await storageRef.put(file);
                  newPhotoURL = await storageRef.getDownloadURL();
                }
                await db.ref(`${layerType}/${gullyId}`).update({
                  status: newStatus,
                  comment: newComment,
                  date: newDate,
                  photoURL: newPhotoURL
                });
                alert('Signage asset updated!');
                window.map.closePopup(currentInspectionPopup);
              } catch (err) {
                alert('Error saving signage asset: ' + err.message);
                saveBtn.textContent = 'Save';
                saveBtn.disabled = false;
              }
            };
          }
        }
      }, 100);
    });
    return; // Prevent running the gully popup code
  }
  // Custom popup for road lining
  if (layerType === 'lining') {
    db.ref(`${layerType}/${gullyId}`).once('value').then(snapshot => {
      const asset = snapshot.val() || {};
      const description = asset.description || 'No description';
      const status = asset.status || '';
      const comment = asset.comment || '';
      const photoURL = asset.photoURL || '';
      const date = asset.date ? new Date(asset.date).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
      const canEdit = (window.currentUserData && (window.currentUserData.role === 'admin' || window.currentUserData.role === 'operator')) || editMode;
      let html = `<div class='inspection-popup popup-form'>`;
      html += `<h3 style='margin-top:0;'>Road Lining Asset</h3>`;
      html += `<div><b>Description of Type of Lining:</b> ${description}</div>`;
      html += `<div><b>Status:</b> <select id='lining-status'>`;
      html += `<option value='New'${status === 'New' ? ' selected' : ''}>New</option>`;
      html += `<option value='Renewed'${status === 'Renewed' ? ' selected' : ''}>Renewed</option>`;
      html += `</select></div>`;
      html += `<div><b>Date:</b><br/><input type='date' id='lining-date' value='${date}' style='width:100%;margin-bottom:5px;'></div>`;
      html += `<div><b>Comment:</b><br/>`;
      html += `<input type='text' id='lining-comment' placeholder='Enter comment' style='width:100%;margin-bottom:5px;' value="${comment || ''}">`;
      html += `</div>`;
      html += `<div><b>Photo:</b><br/>`;
      if (photoURL) {
        html += `<a href='${photoURL}' target='_blank' style='color:blue;'>📷 View Photo</a><br/>`;
        html += `<img src='${photoURL}' alt='Lining Photo' style='max-width:100%;max-height:100px;margin:5px 0;display:block;'>`;
      }
      if (canEdit) {
        html += `<input type='file' id='lining-photo' accept='image/*' style='margin-top:5px;display:none;'/><br/>`;
        html += `<button id='take-photo-btn' type='button' style='margin:5px 0;'>📸 Take Photo</button>`;
        html += `<img id='lining-photo-preview' style='max-width:100%;max-height:100px;display:none;margin:5px 0;'>`;
      }
      html += `</div>`;
      if (canEdit) {
        html += `<div style='margin-top:8px;display:flex;align-items:center;gap:8px;'>`;
        html += `<input type='checkbox' id='confirm-save-lining' style='margin-right:4px;'>`;
        html += `<label for='confirm-save-lining' style='margin:0;'>Confirm Save</label>`;
        html += `<button id='save-lining' style='margin-left:8px;' disabled>Save</button>`;
        html += `</div>`;
      }
      html += `<div class='d-flex gap-2 justify-content-end mt-3'>`;
      if (canEdit) {
        html += `<button id='save-lining' class='btn btn-success flex-fill' type='button' disabled>Save</button>`;
      }
      html += `<button id='view-history' class='btn btn-outline-secondary flex-fill' type='button'>View History</button>`;
      html += `</div>`;
      html += `</div>`;
      // Remove any existing modal
      document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
      const inspectionBackdrop = document.createElement('div');
      inspectionBackdrop.className = 'modal-backdrop-custom';
      inspectionBackdrop.onclick = function(e) { if (e.target === inspectionBackdrop) inspectionBackdrop.remove(); };
      const modal = document.createElement('div');
      modal.className = 'card shadow p-4';
      modal.style.maxWidth = '400px';
      modal.style.maxHeight = '90vh';
      modal.style.overflowY = 'auto';
      modal.innerHTML = `
        <div class="d-flex justify-content-between align-items-center mb-3">
          <h3 class="m-0">Road Lining Asset</h3>
          <button class="btn btn-secondary" onclick="this.closest('.card').parentElement.remove()">✖ Close</button>
        </div>
        <div>${html}</div>
      `;
      inspectionBackdrop.appendChild(modal);
      document.body.appendChild(inspectionBackdrop);
      // Re-attach event handlers as before (photo preview, save, etc.)
      setTimeout(() => {
        if (canEdit) {
          // Photo preview logic
          const photoInput = document.getElementById('lining-photo');
          const photoPreview = document.getElementById('lining-photo-preview');
          if (photoInput && photoPreview) {
            photoInput.onchange = function() {
              if (photoInput.files && photoInput.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                  photoPreview.src = e.target.result;
                  photoPreview.style.display = 'block';
                };
                reader.readAsDataURL(photoInput.files[0]);
              } else {
                photoPreview.style.display = 'none';
              }
            };
          }
          // Take Photo button
          const takePhotoBtn = document.getElementById('take-photo-btn');
          if (takePhotoBtn && photoInput) {
            takePhotoBtn.onclick = function() {
              photoInput.setAttribute('capture', 'environment');
              photoInput.click();
            };
          }
          // Confirm Save checkbox
          const confirmSave = document.getElementById('confirm-save-lining');
          const saveBtn = document.getElementById('save-lining');
          if (confirmSave && saveBtn) {
            confirmSave.onchange = function() {
              saveBtn.disabled = !confirmSave.checked;
            };
            saveBtn.disabled = !confirmSave.checked;
          }
          // Save logic
          if (saveBtn) {
            saveBtn.onclick = async function() {
              if (saveBtn.disabled) return;
              try {
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;
                const newStatus = document.getElementById('lining-status').value;
                const newComment = document.getElementById('lining-comment').value;
                const newDate = document.getElementById('lining-date').value;
                let newPhotoURL = photoURL;
                if (photoInput && photoInput.files && photoInput.files[0]) {
                  const file = photoInput.files[0];
                  const storageRef = storage.ref(`${layerType}/${gullyId}/${Date.now()}_${file.name}`);
                  await storageRef.put(file);
                  newPhotoURL = await storageRef.getDownloadURL();
                }
                await db.ref(`${layerType}/${gullyId}`).update({
                  status: newStatus,
                  comment: newComment,
                  date: newDate,
                  photoURL: newPhotoURL
                });
                alert('Road lining asset updated!');
                window.map.closePopup(currentInspectionPopup);
              } catch (err) {
                alert('Error saving road lining asset: ' + err.message);
                saveBtn.textContent = 'Save';
                saveBtn.disabled = false;
              }
            };
          }
        }
      }, 100);
    });
    return; // Prevent running the gully popup code
  }
}

// Add the loadFromBackup function
function loadFromBackup() {
  if (!auth.currentUser) {
    alert('Please log in to load backup data');
    return;
  }
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,application/json';
  input.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const backup = JSON.parse(text);
      // Clear all layers and gullyData
      Object.values(window.dataLayers).forEach(layer => layer.clearLayers());
      gullyData.length = 0;
      // Add features from backup
      Object.keys(backup).forEach(layerType => {
        const items = backup[layerType] || {};
        Object.entries(items).forEach(([id, item]) => {
          if (item.location) {
            addGullyToMap(item.location, id, layerType, item.status || 'Unmarked');
          }
        });
      });
      initializeLayerVisibility();
      alert('Backup loaded successfully!');
    } catch (err) {
      alert('Error loading backup: ' + err.message);
    }
  };
  input.click();
}

// Forgot password handler (attach directly, not in DOMContentLoaded)
const forgotLink = document.getElementById('forgotPasswordLink');
if (forgotLink) {
  forgotLink.onclick = function(e) {
    e.preventDefault();
    let email = document.getElementById('email').value.trim();
    if (!email) {
      email = prompt('Please enter your email address to reset your password:');
      if (!email) return;
    }
    // Normalize and validate email
    const validation = validateAndNormalizeEmail(email);
    if (!validation.isValid) {
      document.getElementById('loginError').style.color = 'red';
      document.getElementById('loginError').textContent = '❌ ' + validation.message;
      return;
    }
    firebase.auth().sendPasswordResetEmail(validation.normalizedEmail)
      .then(() => {
        document.getElementById('loginError').style.color = 'green';
        document.getElementById('loginError').textContent = '✔️ Password reset email sent. Please check your inbox.';
      })
      .catch(error => {
        document.getElementById('loginError').style.color = 'red';
        document.getElementById('loginError').textContent = '❌ ' + (error.message || 'Error sending password reset email.');
      });
  };
}

// The quick-comment dropdown logic is now handled inside each popup function where canEdit is defined.

    // --- DRAGGABLE LAYER CONTROL POPUP ---
    // Add draggable functionality to the layer control card
    function makeLayerControlDraggable() {
      const container = document.getElementById('layerControlContainer');
      if (!container) return;
      let isDragging = false;
      let offsetX = 0, offsetY = 0;
      const header = container.querySelector('.card-header');
      if (!header) return;
      header.style.cursor = 'move';
      header.onmousedown = function(e) {
        isDragging = true;
        offsetX = e.clientX - container.offsetLeft;
        offsetY = e.clientY - container.offsetTop;
        document.onmousemove = function(e) {
          if (!isDragging) return;
          container.style.left = (e.clientX - offsetX) + 'px';
          container.style.top = (e.clientY - offsetY) + 'px';
          container.style.right = 'auto';
        };
        document.onmouseup = function() {
          isDragging = false;
          document.onmousemove = null;
          document.onmouseup = null;
        };
      };
    }
    // Call this after creating the layer control container
    function createLayerControlContainer() {
      const container = document.createElement('div');
      container.id = 'layerControlContainer';
      container.className = 'layer-control-card card shadow';
      container.style.display = 'block';

      // Build the layer list HTML
      let layerListHTML = '';
      const layers = [
        { key: 'gullies', name: 'Gullies', desc: 'Drainage inspection points', iconClass: 'gully-icon' },
        { key: 'playgrounds', name: 'Playgrounds', desc: 'Recreational areas', iconClass: 'playground-icon' },
        { key: 'walkways', name: 'Walkways', desc: 'Pedestrian paths', iconClass: 'walkway-icon' },
        { key: 'signage', name: 'Signage', desc: 'Information signs', iconClass: 'signage-icon' },
        { key: 'lining', name: 'Road Lining', desc: 'Road markings', iconClass: 'lining-icon' }
      ];
      layers.forEach(layer => {
        layerListHTML += `
          <div class="layer-item" onclick="toggleLayer('${layer.key}')">
            <div class="layer-checkbox">
              <input class="form-check-input" type="checkbox" id="${layer.key}Layer" ${window.map && window.dataLayers[layer.key] && window.map.hasLayer(window.dataLayers[layer.key]) ? 'checked' : ''}>
            </div>
            <div class="layer-icon-container">
              <div class="layer-icon ${layer.iconClass}"></div>
            </div>
            <div class="layer-info">
              <div class="layer-name">${layer.name}</div>
              <div class="layer-description">${layer.desc}</div>
            </div>
          </div>
        `;
      });

      if (!layerListHTML) {
        layerListHTML = `<div class="text-muted text-center py-3">No layers available</div>`;
      }

      container.innerHTML = `
        <div class="layer-header">
          <div class="layer-header-content">
            <div class="drag-handle" title="Drag to move">
              <i class="bi bi-grip-vertical"></i>
            </div>
            <div class="layer-title">
              <i class="bi bi-layers-fill me-2"></i>
              <span>Map Layers</span>
            </div>
          </div>
          <button type="button" class="layer-close-btn" aria-label="Close" id="closeLayerControlBtn">
            <i class="bi bi-x-lg"></i>
          </button>
        </div>
        <div class="layer-content">
          <div class="layer-description">
            <small class="text-muted">Select which layers to display on the map</small>
          </div>
          <div class="layer-list">
            ${layerListHTML}
          </div>
        </div>
      `;

      document.body.appendChild(container);
      updateLayerButtonStates();
      setTimeout(() => {
        const closeBtn = document.getElementById('closeLayerControlBtn');
        if (closeBtn) {
          closeBtn.onclick = function() {
            container.style.display = 'none';
          };
        }
        makeLayerControlDraggable();
      }, 0);
    }

    // --- ENHANCED DRAGGABLE FOR TOUCH (TABLET) ---
    function makeLayerControlDraggable() {
      const container = document.getElementById('layerControlContainer');
      if (!container) return;
      let isDragging = false;
      let offsetX = 0, offsetY = 0;
      const header = container.querySelector('.card-header');
      if (!header) return;
      header.style.cursor = 'move';

      // Mouse events
      header.onmousedown = function(e) {
        isDragging = true;
        offsetX = e.clientX - container.offsetLeft;
        offsetY = e.clientY - container.offsetTop;
        document.onmousemove = function(e) {
          if (!isDragging) return;
          container.style.left = (e.clientX - offsetX) + 'px';
          container.style.top = (e.clientY - offsetY) + 'px';
          container.style.right = 'auto';
        };
        document.onmouseup = function() {
          isDragging = false;
          document.onmousemove = null;
          document.onmouseup = null;
        };
      };

      // Touch events for tablet/mobile
      header.ontouchstart = function(e) {
        if (e.touches.length !== 1) return;
        isDragging = true;
        const touch = e.touches[0];
        offsetX = touch.clientX - container.offsetLeft;
        offsetY = touch.clientY - container.offsetTop;
        document.ontouchmove = function(e) {
          if (!isDragging || e.touches.length !== 1) return;
          const moveTouch = e.touches[0];
          container.style.left = (moveTouch.clientX - offsetX) + 'px';
          container.style.top = (moveTouch.clientY - offsetY) + 'px';
          container.style.right = 'auto';
        };
        document.ontouchend = function() {
          isDragging = false;
          document.ontouchmove = null;
          document.ontouchend = null;
        };
      };
    }

    // Add base layers for OSM and Esri Satellite
    let osiLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19
    });
    let satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri',
      maxZoom: 19
    });
    let isSatellite = false;

    // Update initMap to use osiLayer as the default
    function initMap() {
      // ... existing code ...
      window.map = L.map('map', {
        center: [51.9, -8.5],
        zoom: 13,
        zoomControl: false,
        attributionControl: false
      });
      osiLayer.addTo(window.map);
      // ... rest of initMap ...
    }

    // Add the toggleMapLayer function
    function toggleMapLayer() {
      if (!window.map) return;
      if (isSatellite) {
        window.map.removeLayer(satelliteLayer);
        osiLayer.addTo(window.map);
        document.getElementById('toggleMapLayerBtn').innerHTML = '<i class="bi bi-globe"></i> Satellite';
      } else {
        window.map.removeLayer(osiLayer);
        satelliteLayer.addTo(window.map);
        document.getElementById('toggleMapLayerBtn').innerHTML = '<i class="bi bi-map"></i> Map';
      }
      // Ensure zoom control is present after switching layers
      if (!window.map.zoomControl) {
        window.map.zoomControl = L.control.zoom({ position: 'topright' }).addTo(window.map);
      }
      isSatellite = !isSatellite;
    }

    // --- USER LOGIN/LOGOUT LOGGING ---
    function logUserEvent(eventType, userEmail) {
      if (!userEmail) return;
      const logRef = db.ref('user_logs').push();
      logRef.set({
        email: userEmail,
        event: eventType,
        timestamp: Date.now()
      });
    }

    // Add Register button below Sign In in the login form
    // Find the login form and add after the Sign In button:
    // <button type="button" class="btn btn-outline-primary w-100 mt-2" onclick="showRegisterModal()">Register</button>

    // Add the Register modal and logic
    function showRegisterModal() {
      document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
      const backdrop = document.createElement('div');
      backdrop.className = 'modal-backdrop-custom';
      backdrop.onclick = function(e) { if (e.target === backdrop) backdrop.remove(); };
      const modal = document.createElement('div');
      modal.className = 'card shadow p-4';
      modal.style.maxWidth = '400px';
      modal.style.maxHeight = '90vh';
      modal.style.overflowY = 'auto';
      modal.innerHTML = `
        <div class="d-flex justify-content-between align-items-center mb-3">
          <h3 class="m-0">Register</h3>
          <button class="btn btn-secondary" onclick="this.closest('.card').parentElement.remove()">✖ Close</button>
        </div>
        <form id="registerForm">
          <div class="mb-3">
            <label for="regEmail" class="form-label">Email</label>
            <input type="email" id="regEmail" class="form-control" required>
          </div>
          <div class="mb-3">
            <label for="regPassword" class="form-label">Password</label>
            <input type="password" id="regPassword" class="form-control" required>
          </div>
          <div class="mb-3">
            <label for="regName" class="form-label">Full Name</label>
            <input type="text" id="regName" class="form-control" required>
          </div>
          <button type="submit" class="btn btn-primary w-100">Register</button>
          <div id="registerError" style="color:red;margin-top:10px;"></div>
        </form>
      `;
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      document.getElementById('registerForm').onsubmit = function(e) {
        e.preventDefault();
        registerUser();
      };
    }

    function registerUser() {
      const email = document.getElementById('regEmail').value.trim();
      const password = document.getElementById('regPassword').value;
      const name = document.getElementById('regName').value.trim();
      const errorDiv = document.getElementById('registerError');
      errorDiv.textContent = '';
      if (!email || !password || !name) {
        errorDiv.textContent = 'Please fill in all fields.';
        return;
      }
      // Optional: restrict to @corkcity.ie
      if (!/@corkcity\.ie$/.test(email)) {
        errorDiv.textContent = 'Registration is only allowed for @corkcity.ie emails.';
        return;
      }
      auth.createUserWithEmailAndPassword(email, password)
        .then(userCredential => {
          const user = userCredential.user;
          db.ref('users/' + user.uid).set({
            email: email,
            name: name,
            role: 'operator',
            initials: name.split(' ').map(n => n[0]).join('').toUpperCase(),
            isAdmin: false,
            approved: false, // admin must approve
            created: firebase.database.ServerValue.TIMESTAMP
          });
          alert('Registration successful! Your account is pending admin approval. You will not be able to log in until approved.');
          document.querySelectorAll('.modal-backdrop-custom').forEach(e => e.remove());
          auth.signOut(); // Ensure user is signed out until approved
        })
        .catch(error => {
          errorDiv.textContent = error.message;
        });
    }

    // Prevent login if not approved
    function login(isAutoLogin = false) {
      const email = document.getElementById("email").value;
      const password = document.getElementById("password").value;
      if (!email || !password) {
        document.getElementById("loginError").textContent = "❌ Please enter both email and password";
        const loginScreen = document.getElementById("loginScreen");
        if (loginScreen) loginScreen.style.opacity = "1";
        return;
      }
      const validation = validateAndNormalizeEmail(email);
      if (!validation.isValid) {
        document.getElementById("loginError").textContent = `❌ ${validation.message}`;
        const loginScreen = document.getElementById("loginScreen");
        if (loginScreen) loginScreen.style.opacity = "1";
        return;
      }
      document.getElementById("loginError").textContent = "Logging in...";
      const loginScreen = document.getElementById("loginScreen");
      if (loginScreen) loginScreen.style.opacity = "0.5";
      auth.signInWithEmailAndPassword(validation.normalizedEmail, password)
        .then(async userCredential => {
          const userRef = db.ref(`users/${userCredential.user.uid}`);
          let snapshot = await userRef.once('value');
          if (!snapshot.exists()) {
            // Try to find user config for this email
            const userConfig = USER_CONFIG.users.find(u => u.email.toLowerCase() === validation.normalizedEmail.toLowerCase());
            if (userConfig) {
              await userRef.set({
                ...userConfig,
                created: firebase.database.ServerValue.TIMESTAMP,
                lastUpdated: firebase.database.ServerValue.TIMESTAMP
              });
              snapshot = await userRef.once('value');
            } else {
              throw new Error('No user data found and no config for this user');
            }
          }
          if (!snapshot.exists()) {
            throw new Error('No user data found');
          }
          const userData = snapshot.val();
          if (userData.approved === false) {
            throw new Error('Your account is pending admin approval. Please contact an administrator.');
          }
          window.currentUserData = userData;
          currentRole = userData.role;
          // Update UI
          const loginScreen = document.getElementById('loginScreen');
          if (loginScreen) loginScreen.style.display = 'none';
          const mapDiv = document.getElementById('map');
          if (mapDiv) mapDiv.style.display = 'block';
          const summaryDiv = document.getElementById('summary');
          if (summaryDiv) summaryDiv.style.display = 'block';
          // Setup UI with proper privileges
          setupUIForRole(userData.role, userData.adminPrivileges);
          // Clear URL parameters after auto-login
          if (isAutoLogin) {
            window.history.replaceState({}, document.title, window.location.pathname);
          }
        })
        .catch(error => {
          console.error('Login error:', error);
          document.getElementById("loginError").textContent = "❌ " + error.message;
          const loginScreen = document.getElementById("loginScreen");
          if (loginScreen) loginScreen.style.opacity = "1";
        });
    }

</script>
</body>
</html>