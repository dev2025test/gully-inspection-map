<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Gully Inspection System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/togeojson.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100%; display: none; }
    #loginScreen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: #f5f5f5; display: flex; align-items: center; justify-content: center; z-index: 10000;
    }
    #loginBox {
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      min-width: 300px;
    }
    #controlPanel {
      top: 10px;
      left: 10px;
      display: none;
      z-index: 1000;
    }
    #summary { top: 10px; right: 10px; font-size: 0.9em; display: none; }
    .dot { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #000; }
    .popup-form input, .popup-form select, .popup-form textarea { width: 100%; margin-bottom: 6px; }
    .inspection-popup .leaflet-popup-content {
      margin: 5px;
      width: auto !important;
    }
    .popup-form input[type="text"],
    .popup-form input[type="date"],
    .popup-form select,
    .popup-form textarea {
      margin: 5px 0;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .popup-form button {
      background: #f0f0f0;
      border: 1px solid #ccc;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
    }
    .popup-form button:hover {
      background: #e0e0e0;
    }
    .popup-form button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .layer-control {
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
      margin-left: 10px;
      margin-top: 10px;
    }
    .layer-control select {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .layer-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .layer-content.expanded {
      max-height: 500px;
    }
    .layer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 5px;
      background: #f5f5f5;
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .layer-header:hover {
      background: #e0e0e0;
    }
    .collapse-icon {
      transition: transform 0.3s ease;
    }
    .collapse-icon.expanded {
      transform: rotate(180deg);
    }
    .login-background {
      background: linear-gradient(rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.9)),
                  url('https://www.corkcity.ie/en/media/cork-city-hall.jpg');
      background-size: cover;
      background-position: center;
    }
    .password-container {
      position: relative;
      display: inline-block;
      width: 100%;
    }
    .password-toggle {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      user-select: none;
    }
    .remember-me {
      margin-top: 10px;
      text-align: left;
    }
    .login-input {
      width: 100%;
      padding: 8px 12px;
      margin: 8px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .login-button {
      background: #2196F3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      font-size: 16px;
      margin-top: 15px;
    }
    .login-button:hover {
      background: #1976D2;
    }
    .ribbon-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 5px;
      background: white;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .ribbon-group {
      border-right: 1px solid #ddd;
      padding: 0 10px;
    }
    .ribbon-group:last-child {
      border-right: none;
    }
    .map-controls {
      position: fixed;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: white;
      padding: 5px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="roleBanner" style="position:absolute;top:10px;left:50%;transform:translateX(-50%);
background:#eee;padding:8px 20px;border-radius:6px;box-shadow:0 0 4px rgba(0,0,0,0.3);z-index:1001;
font-weight:bold;"></div>

<div id="loginScreen" class="login-background">
  <div id="loginBox">
    <h2>Welcome to Gully Inspection System</h2>
    <form id="loginForm" autocomplete="on">
      <input type="email" id="email" placeholder="Email" class="login-input" autocomplete="username">
      <div class="password-container">
        <input type="password" id="password" placeholder="Password" class="login-input" autocomplete="current-password">
        <span class="password-toggle" onclick="togglePassword()">üëÅÔ∏è</span>
      </div>
      <div class="remember-me">
        <label>
          <input type="checkbox" id="rememberMe"> Remember me
        </label>
      </div>
      <button type="submit" class="login-button" onclick="login(); return false;">Login</button>
    </form>
    <p id="loginError" style="color:red;"></p>
  </div>
</div>

<div id="map"></div>

<div id="controlPanel" class="ribbon-bar">
  <div class="ribbon-group">
    <button onclick="captureScreen()" title="Capture Screen" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üì∏ Capture</button>
    <button onclick="printMap()" title="Print Map" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üñ®Ô∏è Print</button>
  </div>
  
  <div class="ribbon-group">
    <label for="importFile" style="background:#ddd;padding:6px 12px;border-radius:4px;cursor:pointer;">üóÇÔ∏è Import</label>
    <input type="file" id="importFile" accept=".kml" style="display:none;">
    <button onclick="exportData()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üíæ Export CSV</button>
  </div>
  
  <div class="ribbon-group">
    <button onclick="resetMap()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">‚ôªÔ∏è Reset</button>
    <button onclick="saveGullyData()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üíæ Backup JSON</button>
  </div>
  
  <div class="ribbon-group">
    <button onclick="enableDeleteMode()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üóëÔ∏è Delete Gully</button>
    <button onclick="enableEditMode()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">‚úèÔ∏è Edit Gully</button>
  </div>
  
  <div class="ribbon-group">
    <select id="activeLayer" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;cursor:pointer;">
      <option value="gullies">üîµ Gullies</option>
      <option value="signage">üö∏ Signage</option>
      <option value="playgrounds">üéÆ Playgrounds</option>
      <option value="parks">üå≥ Parks</option>
      <option value="walkways">üö∂ Walkways</option>
      <option value="lining">üé® Lining</option>
    </select>
  </div>
  
  <div class="ribbon-group">
    <button onclick="logout()" style="padding:6px 12px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">üö™ Logout</button>
  </div>
</div>

<div class="map-controls">
  <button onclick="map.zoomIn()" style="display:block;margin-bottom:5px;padding:6px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">‚ûï</button>
  <button onclick="map.zoomOut()" style="display:block;padding:6px;border-radius:4px;background:#f0f0f0;border:1px solid #ccc;">‚ûñ</button>
</div>

<div id="summary">
  <b>Summary</b><br>
  <div id="summaryContent"></div>
  <label>Filter:</label>
  <select id="filterStatus" onchange="filterByStatus()">
    <option value="All">All</option>
    <option value="Clear">Clear</option>
    <option value="Broken">Broken</option>
    <option value="Remediation">Remediation</option>
    <option value="Replacement">Replacement</option>
    <option value="Blocked">Blocked</option>
    <option value="Expired">Expired</option>
  </select>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBsteq-tHQdiDcRk5UBg52AwAxpVcq67cw",
  authDomain: "gullytest3.firebaseapp.com",
  databaseURL: "https://gullytest3-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "gullytest3",
  storageBucket: "gullytest3.appspot.com",
  messagingSenderId: "876083677912",
  appId: "1:876083677912:web:065de0c7cca446b78f65ad"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
const storage = firebase.storage();

// User management configuration
const USER_CONFIG = {
  defaultPassword: 'DefaultPass123!',
  users: [
    {
      email: 'shane_dorgan@corkcity.ie',
      role: 'admin',
      name: 'Shane Dorgan',
      initials: 'SD',
      isAdmin: true,
      adminPrivileges: {
        canDelete: true,
        canEdit: true,
        canImport: true,
        canExport: true,
        canReset: true,
        canManageUsers: true
      }
    },
    {
      email: 'aman_kushwaha@corkcity.ie',
      role: 'admin',
      name: 'Aman Kushwaha',
      initials: 'AK',
      isAdmin: true,
      adminPrivileges: {
        canDelete: true,
        canEdit: true,
        canImport: true,
        canExport: true,
        canReset: true,
        canManageUsers: true
      }
    },
    {
      email: 'ronan_oconnor@corkcity.ie',
      role: 'operator',
      name: "Ronan O'Connor",
      initials: 'RO',
      isAdmin: false
    }
  ]
};

// Function to validate and normalize email variations
function validateAndNormalizeEmail(email) {
  if (!email) return { isValid: false, normalizedEmail: '', message: 'Email is required' };
  
  email = email.toLowerCase().trim();
  
  // Admin email variations
  const adminVariations = [
    'shane_dorgan@corkcity.ie',
    'shane.dorgan@corkcity.ie',
    'shanedorgan@corkcity.ie',
    'aman_kushwaha@corkcity.ie',
    'aman.kushwaha@corkcity.ie',
    'nan_kushwaha@corkcity.ie',
    'nan.kushwaha@corkcity.ie',
    'aman_kushawaha@corkcity.ie',
    'aman.kushawaha@corkcity.ie',
    'amankushwaha@corkcity.ie',
    'nankushwaha@corkcity.ie'
  ];
  
  // Operator email variations
  const operatorVariations = [
    'ronan_oconnor@corkcity.ie',
    'ronan.oconnor@corkcity.ie',
    'ronan_o_connor@corkcity.ie',
    'ronan.o.connor@corkcity.ie',
    'ronanoconnor@corkcity.ie'
  ];
  
  // Check admin variations
  if (adminVariations.some(variant => 
    email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
    return {
      isValid: true,
      normalizedEmail: USER_CONFIG.users[0].email,
      isAdmin: true,
      userData: USER_CONFIG.users[0],
      message: 'Admin email validated'
    };
  }
  
  // Check operator variations
  if (operatorVariations.some(variant => 
    email.replace(/[._]/g, '').toLowerCase() === variant.replace(/[._]/g, '').toLowerCase())) {
    return {
      isValid: true,
      normalizedEmail: USER_CONFIG.users[1].email,
      isAdmin: false,
      userData: USER_CONFIG.users[1],
      message: 'Operator email validated'
    };
  }
  
  return {
    isValid: false,
    normalizedEmail: '',
    message: 'Invalid email. Must be an authorized @corkcity.ie address'
  };
}

// Function to handle automatic login from URL
function handleAutoLogin() {
  const urlParams = new URLSearchParams(window.location.search);
  const email = urlParams.get('email');
  const autoLogin = urlParams.get('autologin');
  
  if (email && autoLogin === 'true') {
    const validation = validateAndNormalizeEmail(email);
    if (validation.isValid) {
      document.getElementById('email').value = validation.normalizedEmail;
      document.getElementById('password').value = USER_CONFIG.defaultPassword;
      login(true); // Pass true to indicate auto-login
    } else {
      document.getElementById('loginError').textContent = `‚ùå ${validation.message}`;
    }
  }
}

// Function to ensure all users exist
async function ensureAllUsers() {
  console.log('Ensuring all users exist...');
  
  for (const user of USER_CONFIG.users) {
    try {
      // Check if user exists
      const methods = await auth.fetchSignInMethodsForEmail(user.email);
      
      if (methods.length === 0) {
        // Create new user
        console.log(`Creating user: ${user.email}`);
        const userCredential = await auth.createUserWithEmailAndPassword(
          user.email,
          USER_CONFIG.defaultPassword
        );
        
        // Set up user data
        await db.ref(`users/${userCredential.user.uid}`).set({
          ...user,
          created: firebase.database.ServerValue.TIMESTAMP,
          lastUpdated: firebase.database.ServerValue.TIMESTAMP
        });
      } else {
        // Update existing user
        console.log(`Updating user: ${user.email}`);
        const userCredential = await auth.signInWithEmailAndPassword(
          user.email,
          USER_CONFIG.defaultPassword
        );
        
        await db.ref(`users/${userCredential.user.uid}`).update({
          ...user,
          lastUpdated: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Sign out after update
        await auth.signOut();
      }
    } catch (error) {
      console.error(`Error setting up user ${user.email}:`, error);
    }
  }
}

// Update login function
function login(isAutoLogin = false) {
  const email = document.getElementById("email").value;
  const password = document.getElementById("password").value;
  const rememberMe = document.getElementById("rememberMe").checked;
  
  if (!email || !password) {
    document.getElementById("loginError").textContent = "‚ùå Please enter both email and password";
    return;
  }

  const validation = validateAndNormalizeEmail(email);
  if (!validation.isValid) {
    document.getElementById("loginError").textContent = `‚ùå ${validation.message}`;
    return;
  }

  document.getElementById("loginError").textContent = "Logging in...";
  document.getElementById("loginScreen").style.opacity = "0.5";

  auth.signInWithEmailAndPassword(validation.normalizedEmail, password)
    .then(userCredential => {
      return db.ref(`users/${userCredential.user.uid}`).once('value');
    })
    .then(snapshot => {
      if (!snapshot.exists()) {
        throw new Error('No user data found');
      }
      
      const userData = snapshot.val();
      window.currentUserData = userData;
      currentRole = userData.role;
      
      // Update UI
      document.getElementById('roleBanner').textContent = 
        `Logged in as ${userData.role.toUpperCase()}${userData.isAdmin ? ' (Admin)' : ''}`;
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('map').style.display = 'block';
      document.getElementById('controlPanel').style.display = 'block';
      document.getElementById('summary').style.display = 'block';
      
      // Setup UI with proper privileges
      setupUIForRole(userData.role, userData.adminPrivileges);
      
      initMap();
      loadGullyData();
      setupInactivityTracking();
      
      // Save credentials if remember me is checked
      if (rememberMe) {
        localStorage.setItem('rememberedEmail', email);
        // Note: We don't store the password for security reasons
      } else {
        localStorage.removeItem('rememberedEmail');
      }
      
      // Clear URL parameters after auto-login
      if (isAutoLogin) {
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    })
    .catch(error => {
      console.error('Login error:', error);
      if (error.code === 'auth/wrong-password' && password === USER_CONFIG.defaultPassword) {
        // Try to reset user with default password
        ensureAllUsers().then(() => {
          login(isAutoLogin); // Retry login
        });
      } else {
        document.getElementById("loginError").textContent = "‚ùå " + error.message;
        document.getElementById("loginScreen").style.opacity = "1";
      }
    });
}

function logout() {
  auth.signOut().then(() => {
    window.location.reload();
  }).catch(error => {
    console.error('Logout error:', error);
    alert('Error during logout: ' + error.message);
  });
}

function setupUIForRole(role, adminPrivileges = null) {
  const isAdmin = role === 'admin';
  const isOperator = role === 'operator';
  
  // Get all control buttons
  const controlButtons = document.querySelectorAll("#controlPanel button");
  
  controlButtons.forEach(btn => {
    const buttonText = btn.innerText.toLowerCase();
    
    // Always enable logout button
    if (buttonText.includes('logout')) {
      btn.disabled = false;
      btn.style.opacity = 1;
      return;
    }
    
    // Handle admin privileges
    if (isAdmin && adminPrivileges) {
      if (buttonText.includes('delete') && !adminPrivileges.canDelete) {
        btn.disabled = true;
        btn.style.opacity = 0.5;
        return;
      }
      if (buttonText.includes('edit') && !adminPrivileges.canEdit) {
        btn.disabled = true;
        btn.style.opacity = 0.5;
        return;
      }
      if (buttonText.includes('reset') && !adminPrivileges.canReset) {
        btn.disabled = true;
        btn.style.opacity = 0.5;
        return;
      }
      // Enable all other buttons for admin
      btn.disabled = false;
      btn.style.opacity = 1;
    } else if (isOperator) {
      // Enable only specific buttons for operator
      const allowedOperations = ['export csv', 'backup json'];
      const isAllowed = allowedOperations.some(op => buttonText.includes(op.toLowerCase()));
      btn.disabled = !isAllowed;
      btn.style.opacity = isAllowed ? 1 : 0.5;
    } else {
      // Disable all buttons for other roles
      btn.disabled = true;
      btn.style.opacity = 0.5;
    }
  });
  
  // Handle file input for admin
  const importFile = document.getElementById("importFile");
  if (importFile) {
    importFile.disabled = !(isAdmin && (!adminPrivileges || adminPrivileges.canImport));
    importFile.style.opacity = importFile.disabled ? 0.5 : 1;
  }
}

function initMap() {
  map = L.map('map', {
    preferCanvas: false,
    zoomControl: false,
    maxZoom: 19,
    attributionControl: false  // Disable default attribution
  }).setView([51.9, -8.5], 13);
  
  // Add Irish-styled tile layer
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'üáÆüá™ Cork City Council GIS | ¬© OpenStreetMap contributors'
  }).addTo(map);
  
  // Add custom attribution control
  const attribution = L.control.attribution({
    position: 'bottomright',
    prefix: false
  }).addTo(map);
  
  // Initialize scale with correction
  updateScaleControl();
  
  // Enable pan hand cursor
  map.getContainer().style.cursor = 'grab';
  map.on('mousedown', function() {
    map.getContainer().style.cursor = 'grabbing';
  });
  map.on('mouseup', function() {
    map.getContainer().style.cursor = 'grab';
  });

  // Add all layers to map
  Object.values(layers).forEach(layer => layer.addTo(map));
  
  initLayerToggles();
  
  document.getElementById('importFile').addEventListener('change', handleKMLImport);
  
  // Call updateScaleControl whenever the map zooms
  map.on('zoomend', updateScaleControl);
}

function initLayerToggles() {
  // Add click handlers for layer toggle buttons
  document.querySelectorAll('.layer-toggle').forEach(button => {
    const layerName = button.dataset.layer;
    
    // Update the icon in the button
    const icon = button.querySelector('span');
    if (layerName === 'playgrounds' || layerName === 'parks') {
      icon.innerHTML = '‚ñ≤'; // Triangle symbol
      icon.style.fontSize = '12px';
    }
    
    button.addEventListener('click', () => {
      const isActive = button.classList.toggle('active');
      button.style.background = isActive ? '#e0e0e0' : '#f0f0f0';
      if (isActive) {
        layers[layerName].addTo(map);
      } else {
        map.removeLayer(layers[layerName]);
      }
    });
    // Start with all layers active
    button.classList.add('active');
    button.style.background = '#e0e0e0';
  });

  // Add change handler for active layer dropdown
  document.getElementById('activeLayer').addEventListener('change', (e) => {
    currentActiveLayer = e.target.value;
  });
}

function getStatusColor(status) {
  const statusColors = {
    // Gully statuses
    'Clear': '#4CAF50',      // Green
    'Blocked': '#FF9800',    // Orange
    'Broken': '#f44336',     // Red
    'Remediation': '#9C27B0', // Purple
    'Replacement': '#795548', // Brown
    'Expired': '#607D8B',    // Blue Grey
    'Unmarked': '#9E9E9E',   // Grey

    // Signage statuses
    'Good': '#4CAF50',       // Green
    'Damaged': '#FF9800',    // Orange
    'Missing': '#f44336',    // Red

    // Playground statuses
    'Operational': '#4CAF50',     // Green
    'Needs Repair': '#FF9800',    // Orange
    'Out of Service': '#f44336',  // Red

    // Park statuses
    'Open': '#4CAF50',           // Green
    'Under Maintenance': '#FF9800', // Orange
    'Closed': '#f44336',         // Red

    // Walkway statuses
    'Obstructed': '#FF9800',     // Orange
    'Under Repair': '#9C27B0',   // Purple

    // Lining statuses
    'Faded': '#FF9800',          // Orange
    'Needs Repainting': '#f44336' // Red
  };

  return statusColors[status] || '#9E9E9E'; // Default to grey if status not found
}

function createDot(color) {
  return L.divIcon({
    className: 'gully-marker',
    html: `<div class='dot' style='background:${color};width:14px;height:14px;border-radius:50%;border:2px solid #000;box-shadow:0 0 2px #fff, 0 0 4px #000;'></div>`,
    iconSize: [18, 18],
    iconAnchor: [9, 9],
    popupAnchor: [0, -9]
  });
}

function createTriangle(color) {
  return L.divIcon({
    className: 'triangle-marker',
    html: `<div style='width:0;height:0;border-left:9px solid transparent;border-right:9px solid transparent;border-bottom:16px solid ${color};filter:drop-shadow(0 0 2px rgba(0,0,0,0.5));'></div>`,
    iconSize: [18, 18],
    iconAnchor: [9, 16],
    popupAnchor: [0, -16]
  });
}

function getMarkerIcon(layerType, status = 'Unmarked') {
  const color = getStatusColor(status);
  
  switch(layerType) {
    case 'playgrounds':
    case 'parks':
      return createTriangle(color);
    default:
      return createDot(color);
  }
}

function addGullyToMap(latlng, gullyId, layerType = 'gullies') {
  const marker = new L.Marker([latlng.lat, latlng.lng], {
    icon: getMarkerIcon(layerType)
  });
  
  if (layers[layerType]) {
    layers[layerType].addLayer(marker);
  } else {
    console.warn('Unknown layer type:', layerType);
    layers.gullies.addLayer(marker);
  }
  
  marker.on('click', () => {
    if (deleteMode) {
      handleGullyDelete(gullyId, marker, layerType);
    } else {
      currentMarker = marker;
      showInspectionPopup(marker, gullyId, latlng, layerType);
    }
  });
  
  marker.setZIndexOffset(1000);
  
  // Add to gullyData with initial status
  gullyData.push({ 
    marker, 
    id: gullyId, 
    layer: layerType,
    status: 'Unmarked'  // Set initial status
  });
  
  return marker;
}

async function handleKMLImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    const text = await file.text();
    const kml = new DOMParser().parseFromString(text, 'text/xml');
    const geojson = toGeoJSON.kml(kml);
    
    if (!geojson || !geojson.features || !geojson.features.length) {
      alert('No valid features found in KML file');
      return;
    }
    
    // Clear existing features
    layers.gullies.clearLayers();
    
    // Process and add features
    geojson.features.forEach(feature => {
      if (feature.geometry && feature.geometry.coordinates) {
        const [lng, lat] = feature.geometry.coordinates;
        const marker = L.marker([lat, lng], {
          icon: L.divIcon({
            className: 'gully-marker',
            html: '<div class="dot" style="background:blue;"></div>'
          })
        });
        
        // Add properties to marker
        marker.feature = {
          properties: feature.properties || {}
        };
        
        layers.gullies.addLayer(marker);
      }
    });
    
    // Fit map to imported features
    const bounds = layers.gullies.getBounds();
    if (bounds.isValid()) {
      map.fitBounds(bounds);
    }
    
    alert('Import successful!');
  } catch (error) {
    console.error('Import error:', error);
    alert('Error importing KML file. Please check the file format.');
  }
}

function isValidCoordinate(lng, lat) {
  return !isNaN(lng) && !isNaN(lat) && 
         lng >= -180 && lng <= 180 && 
         lat >= -90 && lat <= 90;
}

function showInspectionPopup(marker, gullyId, latlng, layerType) {
  // Close any existing popup first
  if (currentInspectionPopup) {
    map.closePopup(currentInspectionPopup);
  }

  const popupContent = document.createElement('div');
  popupContent.className = 'popup-form';
  popupContent.style.padding = '10px';

  // Create form HTML with proper event handling
  popupContent.innerHTML = `
    <div style="margin-bottom: 10px;">
      <label>
        <input type="checkbox" id="inspection-complete" style="margin-right: 5px;">
        Inspection Complete
      </label>
    </div>
    
    <div style="margin-bottom: 10px;">
      <label>Date:</label>
      <input type="date" id="inspection-date" 
        value="${new Date().toISOString().split('T')[0]}" 
        max="${new Date().toISOString().split('T')[0]}"
        style="width: 100%;">
    </div>
    
    <div style="margin-bottom: 10px;">
      <label>Status:</label>
      <select id="inspection-status" style="width: 100%;">
        ${getStatusOptionsForLayer(layerType)}
      </select>
    </div>

    <div style="margin-bottom: 10px;">
      <label>Comments:</label>
      <textarea id="inspection-comment" placeholder="Add inspection comments..." style="width: 100%; height: 60px;"></textarea>
    </div>
    
    <div style="margin-bottom: 10px;">
      <label>Photo:</label>
      <div style="display: flex; flex-direction: column; gap: 10px;">
        <input type="file" id="inspection-photo" accept="image/*" style="width: 100%;">
        <button onclick="capturePhoto()" style="background: #2196F3; color: white; border: none; padding: 8px; border-radius: 4px; width: 100%;">
          üì∏ Take Picture
        </button>
      </div>
    </div>
    
    <div style="margin-top: 15px; display: flex; justify-content: space-between;">
      <button id="save-inspection-btn" style="flex: 1; margin-right: 10px; background: #4CAF50; color: white; border: none; padding: 8px; border-radius: 4px;">
        üíæ Save Inspection
      </button>
      <button onclick="viewGullyHistory('${gullyId}')" style="flex: 1; background: #2196F3; color: white; border: none; padding: 8px; border-radius: 4px;">
        üìã View History
      </button>
    </div>
  `;

  // Create popup
  const popup = L.popup({
    maxWidth: 300,
    className: 'inspection-popup',
    closeButton: true,
    autoClose: false,
    closeOnClick: false
  })
  .setLatLng(latlng)
  .setContent(popupContent);

  currentInspectionPopup = popup;
  marker.bindPopup(popup).openPopup();

  // Add event listener after the popup is added to DOM
  setTimeout(() => {
    const saveButton = document.getElementById('save-inspection-btn');
    if (saveButton) {
      saveButton.addEventListener('click', () => {
        saveInspection(gullyId, marker, layerType);
      });
    }
  }, 100);
}

function getStatusOptionsForLayer(layerType) {
  const options = {
    gullies: ['Clear', 'Blocked', 'Broken', 'Remediation', 'Replacement'],
    signage: ['Good', 'Damaged', 'Missing'],
    playgrounds: ['Operational', 'Needs Repair', 'Out of Service'],
    parks: ['Open', 'Under Maintenance', 'Closed'],
    walkways: ['Clear', 'Obstructed', 'Under Repair'],
    lining: ['Good', 'Faded', 'Needs Repainting']
  };

  return (options[layerType] || []).map(status => 
    `<option value="${status}">${status}</option>`
  ).join('');
}

// Update saveInspection to properly handle the status update
async function saveInspection(gullyId, marker, layerType) {
  if (!auth.currentUser) {
    alert('You must be logged in to save inspections');
    return;
  }

  const formData = {
    complete: document.getElementById('inspection-complete').checked,
    date: document.getElementById('inspection-date').value,
    status: document.getElementById('inspection-status').value,
    comment: document.getElementById('inspection-comment').value,
    location: marker.getLatLng()
  };

  if (!formData.complete) {
    alert('Please mark inspection as complete');
    return;
  }

  try {
    // Get current user data
    const userData = window.currentUserData;
    if (!userData) {
      throw new Error('User data not found. Please log out and log in again.');
    }

    // Create inspection data
    const timestamp = Date.now();
    const inspectionData = {
      date: formData.date,
      status: formData.status,
      comment: formData.comment,
      complete: formData.complete,
      timestamp: timestamp,
      inspector: {
        name: userData.name || auth.currentUser.email.split('@')[0].replace(/[._]/g, ' '),
        email: auth.currentUser.email,
        uid: auth.currentUser.uid,
        role: userData.role,
        initials: userData.initials || auth.currentUser.email.substring(0, 2).toUpperCase()
      }
    };

    // Handle photo upload if present
    const photoFile = document.getElementById('inspection-photo').files[0];
    if (photoFile) {
      try {
        const photoRef = storage.ref(`photos/${gullyId}/${timestamp}_${photoFile.name}`);
        await photoRef.put(photoFile);
        inspectionData.photoURL = await photoRef.getDownloadURL();
      } catch (error) {
        console.error('Photo upload failed:', error);
        alert('Warning: Photo upload failed, but inspection will still be saved.');
      }
    }

    // Update gully data in memory
    const gullyIndex = gullyData.findIndex(g => g.id === gullyId);
    if (gullyIndex !== -1) {
      gullyData[gullyIndex].status = formData.status;
    }

    // Save to Firebase
    const updates = {};
    updates[`gullies/${gullyId}/inspections/${timestamp}`] = inspectionData;
    updates[`gullies/${gullyId}/status`] = formData.status;
    updates[`gullies/${gullyId}/lastInspection`] = timestamp;
    updates[`gullies/${gullyId}/lastInspector`] = inspectionData.inspector;
    updates[`gully_history/${gullyId}/${timestamp}`] = inspectionData;

    await db.ref().update(updates);

    // Update marker appearance
    updateMarkerStatus(marker, formData.status, layerType);
    
    // Force summary update
    updateSummary();
    
    // Show success message
    alert('Inspection saved successfully');
    
    // Clear form
    document.getElementById('inspection-complete').checked = false;
    document.getElementById('inspection-comment').value = '';
    document.getElementById('inspection-photo').value = '';
    
    // Keep popup open for another inspection
    showInspectionPopup(marker, gullyId, formData.location, layerType);

  } catch (error) {
    console.error('Save inspection error:', error);
    alert('Error saving inspection: ' + error.message);
  }
}

function capturePhoto() {
  try {
    const photoInput = document.getElementById('inspection-photo');
    // Create a temporary input for capturing photos
    const tempInput = document.createElement('input');
    tempInput.type = 'file';
    tempInput.accept = 'image/*';
    tempInput.capture = 'environment'; // Use the back camera
    
    // When a photo is selected, copy it to the main photo input
    tempInput.onchange = function() {
      if (this.files && this.files[0]) {
        photoInput.files = this.files;
      }
    };
    
    tempInput.click();
  } catch (error) {
    console.error('Error capturing photo:', error);
    alert('Error capturing photo. Please try again.');
  }
}

function updateMarkerStatus(marker, status, layerType) {
  const newIcon = getMarkerIcon(layerType, status);
  marker.setIcon(newIcon);
  
  // Update gullyData status
  const gullyIndex = gullyData.findIndex(g => g.marker === marker);
  if (gullyIndex !== -1) {
    gullyData[gullyIndex].status = status;
  }
  
  // Force summary update
  updateSummary();
}

async function viewGullyHistory(gullyId) {
  try {
    // Get history from both locations
    const [inspectionsSnapshot, historySnapshot] = await Promise.all([
      db.ref(`gullies/${gullyId}/inspections`).once('value'),
      db.ref(`gully_history/${gullyId}`).once('value')
    ]);
    
    // Combine and sort all inspections
    const allInspections = [];
    
    // Add inspections from main gully record
    if (inspectionsSnapshot.exists()) {
      Object.values(inspectionsSnapshot.val()).forEach(inspection => {
        allInspections.push(inspection);
      });
    }
    
    // Add inspections from history
    if (historySnapshot.exists()) {
      Object.values(historySnapshot.val()).forEach(inspection => {
        allInspections.push(inspection);
      });
    }
    
    // Sort by timestamp, most recent first
    allInspections.sort((a, b) => b.timestamp - a.timestamp);
    
    // Create history display
    const historyHtml = allInspections.map(inspection => {
      const date = new Date(inspection.timestamp).toLocaleString();
      const inspectorInfo = inspection.inspector || {};
      const inspectorName = inspectorInfo.name || 'Unknown';
      const inspectorInitials = inspectorInfo.initials || 'UN';
      const status = inspection.status || 'Unknown';
      const photoHtml = inspection.photoURL ? 
        `<br><a href="${inspection.photoURL}" target="_blank" style="color: blue;">üì∑ View Photo</a>` : '';
      
      return `
        <div style="border-bottom: 1px solid #ccc; margin-bottom: 10px; padding-bottom: 10px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <strong style="font-size: 1.1em;">${date}</strong>
            <div>
              <span style="background: #e0e0e0; padding: 2px 8px; border-radius: 4px; font-weight: bold;">${inspectorInitials}</span>
            </div>
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Inspector:</span> ${inspectorName}
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Status:</span> 
            <span style="color: ${getStatusColor(status)};">${status}</span>
          </div>
          <div style="margin: 5px 0;">
            <span style="font-weight: bold;">Comments:</span><br>
            ${inspection.comment || 'None'}
          </div>
          ${photoHtml}
        </div>
      `;
    }).join('');
    
    // Create and show modal
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      max-width: 80%;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 10000;
    `;
    
    modal.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin: 0;">Inspection History</h3>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="border: none; background: #f0f0f0; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
          ‚úñ Close
        </button>
      </div>
      <div>${historyHtml || 'No inspection history available'}</div>
    `;
    
    document.body.appendChild(modal);
    
  } catch (error) {
    console.error('Error loading history:', error);
    alert('Error loading history: ' + error.message);
  }
}

function loadGullyData() {
  // Clear existing data
  gullyData.length = 0;
  Object.values(layers).forEach(layer => layer.clearLayers());
  
  Object.keys(layers).forEach(layerType => {
    db.ref(layerType).on('value', snapshot => {
      const data = snapshot.val() || {};
      
      Object.entries(data).forEach(([id, item]) => {
        if (item.location) {
          const marker = addGullyToMap(item.location, id, layerType);
          if (item.status) {
            updateMarkerStatus(marker, item.status, layerType);
            // Store the status in gullyData
            const gullyIndex = gullyData.findIndex(g => g.id === id);
            if (gullyIndex !== -1) {
              gullyData[gullyIndex].status = item.status;
            }
          }
        }
      });
      
      // Update summary after loading data
      updateSummary();
    });
  });
}

// Initialize auth state listener
auth.onAuthStateChanged(user => {
  if (user) {
    console.log('User logged in:', user.email);
    db.ref('users/' + user.uid).once('value').then(snapshot => {
      const userData = snapshot.val();
      if (!userData) {
        console.error('No user data found');
        return;
      }
      window.currentUserData = userData;
      currentRole = userData.role;
      
      document.getElementById('roleBanner').textContent = `Logged in as ${userData.role.toUpperCase()}`;
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('map').style.display = 'block';
      document.getElementById('controlPanel').style.display = 'block';
      document.getElementById('summary').style.display = 'block';
      
      initMap();
      loadGullyData();
      setupUIForRole(userData.role, userData.adminPrivileges);
      setupInactivityTracking();
    });
  } else {
    console.log('No user logged in');
    window.currentUserData = null;
    currentRole = null;
    document.getElementById('loginScreen').style.display = 'block';
    document.getElementById('map').style.display = 'none';
    document.getElementById('controlPanel').style.display = 'none';
    document.getElementById('summary').style.display = 'none';
  }
});

// Update the summary display with descriptions
function updateSummary() {
  const counts = {
    'All': 0,
    'Clear': 0,
    'Blocked': 0,
    'Broken': 0,
    'Remediation': 0,
    'Replacement': 0,
    'Expired': 0,
    'Unmarked': 0
  };

  const descriptions = {
    'All': 'Total number of gullies in the system',
    'Clear': 'Gullies that are clean and functioning properly',
    'Blocked': 'Gullies that are obstructed and need cleaning',
    'Broken': 'Gullies that are damaged and not functioning',
    'Remediation': 'Gullies that require maintenance work',
    'Replacement': 'Gullies that need to be completely replaced',
    'Expired': 'Gullies that need immediate inspection',
    'Unmarked': 'Gullies that have not been inspected yet'
  };
  
  // Count gullies by status
  gullyData.forEach(gully => {
    if (gully.layer === 'gullies') {
      counts['All']++;
      const status = gully.status || 'Unmarked';
      if (counts.hasOwnProperty(status)) {
        counts[status]++;
      }
    }
  });
  
  // Create filter dropdown HTML
  let filterHtml = `
    <div style="margin-bottom: 15px;">
      <div style="margin-bottom: 10px;"><strong>Filter Gullies</strong></div>
      <select id="filterStatus" onchange="filterByStatus()" style="width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
        <option value="All">Show All (${counts['All']})</option>
  `;
  
  // Add options for each status that has gullies
  Object.entries(counts).forEach(([status, count]) => {
    if (status !== 'All' && count > 0) {
      filterHtml += `<option value="${status}">${status} (${count})</option>`;
    }
  });
  
  filterHtml += `
      </select>
    </div>
  `;
  
  // Update summary display with descriptions
  let summaryHtml = '<div style="margin-bottom: 15px;"><strong>Gully Status Summary</strong></div>';
  Object.entries(counts).forEach(([status, count]) => {
    if (status === 'All' || count > 0) {
      const color = getStatusColor(status);
      summaryHtml += `
        <div style="margin: 8px 0;">
          <div style="display: flex; align-items: center;">
            <span style="display: inline-block; width: 12px; height: 12px; background: ${color}; border-radius: 50%; margin-right: 5px; border: 1px solid #000;"></span>
            <span style="flex: 1; font-weight: bold;">${status}: ${count}</span>
          </div>
          <div style="margin-left: 17px; font-size: 0.9em; color: #666;">
            ${descriptions[status]}
          </div>
        </div>
      `;
    }
  });
  
  const summaryContent = document.getElementById('summaryContent');
  if (summaryContent) {
    summaryContent.innerHTML = filterHtml + summaryHtml;
  }
  
  // Reapply current filter if exists
  const filterStatus = document.getElementById('filterStatus');
  if (filterStatus && filterStatus.value !== 'All') {
    filterByStatus();
  }
}

// Update the filter functionality
function filterByStatus() {
  const selectedStatus = document.getElementById('filterStatus').value;
  
  // Hide all markers first
  gullyData.forEach(gully => {
    if (gully.layer === 'gullies') {
      gully.marker.setOpacity(0.2);
    }
  });
  
  // Show markers that match the filter
  if (selectedStatus === 'All') {
    gullyData.forEach(gully => {
      if (gully.layer === 'gullies') {
        gully.marker.setOpacity(1);
      }
    });
  } else {
    gullyData.forEach(gully => {
      if (gully.layer === 'gullies' && gully.status === selectedStatus) {
        gully.marker.setOpacity(1);
      }
    });
  }
}

// Fix the export CSV function
function exportData() {
  if (!auth.currentUser) {
    alert('Please log in to export data');
    return;
  }

  try {
    // Get all gully data from Firebase
    db.ref('gullies').once('value')
      .then(snapshot => {
        const data = snapshot.val() || {};
        
        // Prepare CSV headers
        let csvContent = 'ID,Latitude,Longitude,Status,Last Inspection,Inspector,Comments\n';
        
        // Process each gully
        Object.entries(data).forEach(([id, gully]) => {
          if (gully.location) {
            const lastInspection = gully.inspections ? 
              Object.values(gully.inspections).sort((a, b) => b.timestamp - a.timestamp)[0] : null;
            
            const row = [
              id,
              gully.location.lat,
              gully.location.lng,
              gully.status || 'Unmarked',
              lastInspection ? new Date(lastInspection.timestamp).toLocaleDateString() : 'Never',
              lastInspection ? lastInspection.inspector.name : 'None',
              lastInspection ? (lastInspection.comment || '').replace(/,/g, ';') : ''
            ];
            
            csvContent += row.join(',') + '\n';
          }
        });
        
        // Create and trigger download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute('href', url);
          link.setAttribute('download', `gully_data_${new Date().toISOString().split('T')[0]}.csv`);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      })
      .catch(error => {
        console.error('Export error:', error);
        alert('Error exporting data: ' + error.message);
      });
  } catch (error) {
    console.error('Export error:', error);
    alert('Error exporting data: ' + error.message);
  }
}

function resetMap() {
  if (!auth.currentUser) {
    alert('You must be logged in to reset the map');
    return;
  }

  if (currentRole !== 'admin') {
    alert('Only administrators can reset the map');
    return;
  }

  const confirmReset = confirm('Are you sure you want to reset the map? This will delete all gullies and their inspection history.');
  if (!confirmReset) {
    return;
  }

  try {
    // Show loading message
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'resetLoadingMessage';
    loadingDiv.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      z-index: 10000;
      text-align: center;
    `;
    loadingDiv.innerHTML = '<h3>Resetting map data...</h3><p>Please wait...</p>';
    document.body.appendChild(loadingDiv);

    // Clear all layers
    Object.values(layers).forEach(layer => {
      layer.clearLayers();
    });

    // Clear memory data
    gullyData.length = 0;
    importedFiles.clear();

    // Clear Firebase data with proper error handling
    const deletePromises = [
      db.ref('gullies').remove(),
      db.ref('gully_history').remove(),
      db.ref('signage').remove(),
      db.ref('playgrounds').remove(),
      db.ref('parks').remove(),
      db.ref('walkways').remove(),
      db.ref('lining').remove()
    ];

    // Also clear storage
    storage.ref().listAll()
      .then(result => {
        const deleteFilePromises = result.items.map(item => item.delete());
        return Promise.all(deleteFilePromises);
      })
      .catch(error => {
        console.error('Error clearing storage:', error);
      });

    // Wait for all deletes to complete
    Promise.all(deletePromises)
      .then(() => {
        // Remove loading message
        const loadingMessage = document.getElementById('resetLoadingMessage');
        if (loadingMessage) {
          loadingMessage.remove();
        }

        // Reset the filter
        const filterStatus = document.getElementById('filterStatus');
        if (filterStatus) {
          filterStatus.value = 'All';
          filterByStatus();
        }

        // Update summary
        updateSummary();

        // Show success message
        alert('Map has been reset successfully');
      })
      .catch(error => {
        console.error('Reset error:', error);
        // Remove loading message
        const loadingMessage = document.getElementById('resetLoadingMessage');
        if (loadingMessage) {
          loadingMessage.remove();
        }
        alert('Error resetting map: ' + error.message);
      });

  } catch (error) {
    console.error('Reset error:', error);
    // Remove loading message
    const loadingMessage = document.getElementById('resetLoadingMessage');
    if (loadingMessage) {
      loadingMessage.remove();
    }
    alert('Error resetting map: ' + error.message);
  }
}

// Update window.onload to include new initialization
window.onload = () => {
  document.getElementById("loginScreen").style.display = "block";
  
  // Initialize users
  Promise.all([
    ensureAllUsers()
  ]).then(() => {
    console.log('User system initialized');
    // Handle auto-login after initialization
    handleAutoLogin();
  }).catch(error => {
    console.error('Error during initialization:', error);
  });
};

function togglePassword() {
  const passwordInput = document.getElementById('password');
  const toggle = document.querySelector('.password-toggle');
  if (passwordInput.type === 'password') {
    passwordInput.type = 'text';
    toggle.textContent = 'üëÅÔ∏è‚Äçüó®Ô∏è';
  } else {
    passwordInput.type = 'password';
    toggle.textContent = 'üëÅÔ∏è';
  }
}

// Load saved email on page load
window.addEventListener('load', function() {
  const savedEmail = localStorage.getItem('rememberedEmail');
  if (savedEmail) {
    document.getElementById('email').value = savedEmail;
    document.getElementById('rememberMe').checked = true;
  }
});

function captureScreen() {
  html2canvas(document.querySelector("#map")).then(canvas => {
    const link = document.createElement('a');
    link.download = 'map-capture.png';
    link.href = canvas.toDataURL();
    link.click();
  });
}

function printMap() {
  window.print();
}

function updateWelcomeMessage(email) {
  const welcomeDiv = document.getElementById('welcomeMessage');
  if (welcomeDiv) {
    welcomeDiv.textContent = `Welcome ${email.split('@')[0]}!`;
    welcomeDiv.style.padding = '10px';
    welcomeDiv.style.background = 'white';
    welcomeDiv.style.borderRadius = '4px';
    welcomeDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    welcomeDiv.style.position = 'absolute';
    welcomeDiv.style.top = '10px';
    welcomeDiv.style.right = '10px';
    welcomeDiv.style.zIndex = '1000';
    welcomeDiv.style.display = 'block';
  }
}

// Update scale control
function updateScaleControl() {
  if (map.scale) map.scale.remove();
  
  map.scale = L.control.scale({
    metric: true,
    imperial: false,
    maxWidth: 200,
    position: 'bottomleft',
    updateWhenIdle: true
  }).addTo(map);
  
  // Custom scale factor to correct the scale
  const scaleFactor = 0.333333; // 1km = 3000m correction
  
  const originalGetScaleText = map.scale._getScaleText;
  map.scale._getScaleText = function(ratio, text) {
    const distance = ratio * scaleFactor;
    if (distance >= 1) {
      return distance.toFixed(0) + ' km';
    } else {
      return (distance * 1000).toFixed(0) + ' m';
    }
  };
}
</script>
</body>
</html>